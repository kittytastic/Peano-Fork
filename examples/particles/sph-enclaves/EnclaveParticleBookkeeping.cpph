#include "EnclaveParticleBookkeeping.h"
#include "EnclaveParticleTask.h"

#include "tarch/Assertions.h"
#include "tarch/multicore/Lock.h"
#include "tarch/multicore/Core.h"
#include "tarch/multicore/Tasks.h"
#include "peano4/parallel/Tasks.h"

#include "tarch/logging/Statistics.h"

#include <algorithm>

template <class Particle, class VTC>
tarch::logging::Log peano4::EnclaveParticleBookkeeping<Particle, VTC>::_log( "peano4::EnclaveParticleBookkeeping" );

template <class Particle, class VTC>
const std::string peano4::EnclaveParticleBookkeeping<Particle, VTC>::MemoryAllocationsInLookupTableIdentifier( "peano4::EnclaveParticleBookkeeping::memory-allocations" );

template <class Particle, class VTC>
const std::string peano4::EnclaveParticleBookkeeping<Particle, VTC>::LookupMissesIdentifier( "peano4::EnclaveParticleBookkeeping::lookup-misses" );



template <class Particle, class VTC>
peano4::EnclaveParticleBookkeeping<Particle, VTC>& peano4::EnclaveParticleBookkeeping<Particle, VTC>::getInstance() {
  static EnclaveParticleBookkeeping<Particle, VTC> singleton;
  return singleton;
}


template <class Particle, class VTC>
void peano4::EnclaveParticleBookkeeping<Particle, VTC>::dumpStatistics() {
  logInfo( "dumpStatistics()", "active tasks=" << tarch::multicore::getNumberOfReservedTaskNumbers() );

  std::ostringstream finishedTasksMsg;
  finishedTasksMsg << "(#" << _finishedTasks.size();
  for (auto& p: _finishedTasks) {
    finishedTasksMsg << "," << p;
  }
  finishedTasksMsg << ")";
  logInfo( "dumpStatistics()", "finished tasks=" << finishedTasksMsg.str() );
}


template <class Particle, class VTC>
void peano4::EnclaveParticleBookkeeping<Particle, VTC>::waitForTasksToTerminate(int taskNumber, const peano4::datamanagement::VertexEnumerator<VTC>& taskCounters) {
  logDebug( "waitForTaskToTerminate(int)", "check for completion of task " << taskNumber );
  tarch::multicore::Lock finishedTasksLock( _tasksSemaphore );
  bool isContained = _finishedTasks.count(taskNumber);
  bool adjacentTasksCompleted = true;
  for (int i=0; i<TwoPowerD; i++) {
    adjacentTasksCompleted &= taskCounters(i).getNumTasksRemaining() == 0;
  }
  finishedTasksLock.free();

  while (not (isContained and adjacentTasksCompleted)) {
    ::tarch::logging::Statistics::getInstance().inc( LookupMissesIdentifier );

    bool processedTasks = ::tarch::multicore::processPendingTasks(ThreePowerD);

    if (not processedTasks) {
      tarch::multicore::yield();
    }

    finishedTasksLock.lock();
    if (not isContained) {
      isContained = _finishedTasks.count(taskNumber);
      if (isContained) {
        _finishedTasks.erase(taskNumber);
        tarch::multicore::releaseTaskNumber(taskNumber);
      }
    }

    if (not adjacentTasksCompleted) {
      adjacentTasksCompleted = true;
      for (int i=0; i<TwoPowerD; i++) {
        adjacentTasksCompleted &= taskCounters(i).getNumTasksRemaining() == 0;
      }
    }
    finishedTasksLock.free();
  }

  logDebug( "waitForTaskToTerminate()", "returned successfully" );
}


template <class Particle, class VTC>
void peano4::EnclaveParticleBookkeeping<Particle, VTC>::spawnTask(EnclaveParticleTask<Particle, VTC>* task, peano4::parallel::Tasks::TaskType priority, const std::string& location) {
  tarch::multicore::Lock lock( _tasksSemaphore );
  for (int i=0; i<TwoPowerD; i++) {
    task->_taskCounters(i).addTask();
  }
  lock.free();

  peano4::parallel::Tasks spawn(
    task,
    priority,
    peano4::parallel::Tasks::getLocationIdentifier( location )
  );
}


template <class Particle, class VTC>
void peano4::EnclaveParticleBookkeeping<Particle, VTC>::finishedTask(int taskNumber, const peano4::datamanagement::VertexEnumerator<VTC>& taskCounters) {
  logDebug( "finishedTask()", "task " << taskNumber << " has terminated. Bookkeep results" );
  tarch::multicore::Lock lockFinishedTasks( _tasksSemaphore );
  assertionEquals( _finishedTasks.count(taskNumber),0 );
  auto oldBucketCount = _finishedTasks.bucket_count();
  _finishedTasks.insert( taskNumber );
  if (_finishedTasks.bucket_count()>oldBucketCount) {
    ::tarch::logging::Statistics::getInstance().inc( MemoryAllocationsInLookupTableIdentifier );
  }
  for (int i=0; i<TwoPowerD; i++) {
    taskCounters(i).removeTask();
  }
  lockFinishedTasks.free();
}
