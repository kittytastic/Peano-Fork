//
// ExaHyPE2 solver file
// Generated by Peano's Python API
// www.peano-framework.org
//
// This is generated. If you change fundamental properties, you will have to 
// generate this file. Backup your manual changes before you do so.
//
#ifndef _examples_exahype2_ccz4_CCZ4_H_
#define _examples_exahype2_ccz4_CCZ4_H_


#include "AbstractCCZ4.h"

#include "tarch/logging/Log.h"

namespace examples {namespace exahype2 {namespace ccz4 {
  class CCZ4;
}}}



class examples::exahype2::ccz4::CCZ4: public AbstractCCZ4 {
  private:
    static tarch::logging::Log   _log;

  public:
    /**
     * I've introduced this one manually to initialise the FORTRAN 
     * subroutines. You can never be sure when this routine is called,
     * i.e. Peano4 might decide to call it very early prior to any
     * proper initialisation of the logging et al. Therefore, I don't
     * use any log statements here.
     */
    CCZ4(); 
    
    
    /**
     * I don't adjust the solution, but I adjust the solution in the very
     * first time step, i.e. I impose initial conditions. For this, I forward
     * the initialisation request to the Fortran routines.
     */
    void adjustSolution(
      double * __restrict__ Q,
      const tarch::la::Vector<Dimensions,double>&  volumeCentre,
      const tarch::la::Vector<Dimensions,double>&  volumeH,
      double                                       t,
      double                                       dt
    )  override;
    
    
    virtual void boundaryConditions(
      const double * __restrict__ Qinside, // Qinside[64+0]
      double * __restrict__ Qoutside, // Qoutside[64+0]
      const tarch::la::Vector<Dimensions,double>&  faceCentre,
      const tarch::la::Vector<Dimensions,double>&  volumeH,
      double                                       t,
      int                                          normal
    )  override;
    


    
    double maxEigenvalue(
      const double * __restrict__ Q, // Q[64+0],
      const tarch::la::Vector<Dimensions,double>&  faceCentre,
      const tarch::la::Vector<Dimensions,double>&  volumeH,
      double                                       t,
      int                                          normal
    ) override;
    


    


    
    void nonconservativeProduct(
      const double * __restrict__ Q, // Q[64+0],
      const double * __restrict__             dQdn, // [64+0]
      const tarch::la::Vector<Dimensions,double>&  faceCentre,
      const tarch::la::Vector<Dimensions,double>&  volumeH,
      double                                       t,
      int                                          normal,
      double * __restrict__ BgradQ // BgradQ[64]
    ) override;
    
};


#endif
