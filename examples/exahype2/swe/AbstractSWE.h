//
// ExaHyPE2 solver file
// Generated by Peano's Python API
// www.peano-framework.org
//
// This is generated. Don't change it! Every rerun of the Python API will
// overwrite your changes.
//
#ifndef _examples_exahype2_swe_AbstractSWE_H_
#define _examples_exahype2_swe_AbstractSWE_H_


#include "exahype2/RefinementControl.h"
#include "exahype2/Solver.h"

#include "tarch/la/Vector.h"

#include "peano4/utils/Globals.h"

#include "TopologyParser.h"

#include "Constants.h"


/**
 * Import for ClawPack's FORTRAN routine
 *
 *
 * See the subchapter "Passing Data Arguments by Value" at
 *
 * https://northstar-www.dartmouth.edu/doc/solaris-forte/manuals/fortran/prog_guide/11_cfort.html
 *
 * By default, FORTRAN routines should have return value int. I don't check
 * error codes anyway, so it does not really make a difference.
 */
extern "C" int rpn2_(int* ixy, int* num_eqn, int* num_aux, int* num_waves, const double * __restrict__ q_l, const double * __restrict__ q_r, const double * __restrict__ aux_l, const double * __restrict__ aux_r, double wave[3][3], double* s, double* amdq, double* apdq);




namespace examples {namespace exahype2 {namespace swe {
  class AbstractSWE;

}}}



class examples::exahype2::swe::AbstractSWE: public ::exahype2::Solver {
  public:
    enum class SolverState {
      GridConstruction,
      GridInitialisation,
      TimeStep,
      Plotting
    };

    static std::string toString(SolverState);

    AbstractSWE();
    

    virtual void sourceTerm(
      const double * __restrict__ Q,
      const tarch::la::Vector<Dimensions,double>&  volumeCentre,
      const tarch::la::Vector<Dimensions,double>&  volumeH,
      double                                       t,
      double                                       dt,
      double * __restrict__ S
    )  final ;

        /**
     * Alias for periodic boundary conditions.
     */
    static std::bitset<Dimensions> PeriodicBC;

    double getMinTimeStamp() const final;
    double getMaxTimeStamp() const final;
    double getMinTimeStepSize() const final;
    double getMaxTimeStepSize() const final;
    
    


    /**
     * @param Q Vector of unknowns
     * @param t Time
     */
    virtual ::exahype2::RefinementCommand refinementCriterion(
      const double * __restrict__ Q, // Q[3+1],
      const tarch::la::Vector<Dimensions,double>&  volumeCentre,
      const tarch::la::Vector<Dimensions,double>&  volumeH,
      double                                       t
    )  final ;


    /**
     * Feel free to change the solution in the particular finite volume.
     * You can for example change the initial conditions by overwriting
     * the solution for t=0. You may change Q. All other parameters are
     * in.
     */
    virtual void adjustSolution(
      double * __restrict__ Q,
      const tarch::la::Vector<Dimensions,double>&  volumeCentre,
      const tarch::la::Vector<Dimensions,double>&  volumeH,
      double                                       t,
      double                                       dt
    )  final ;


    /**
     * Apply boundary conditions. You can overwrite both the inside and
     * outside values though most BCs only modify the outside ones. Please
     * note that the boundary conditions you set here are after that subject
     * to the Riemann solver, i.e. flux and eigenvalues.
     */
    virtual void boundaryConditions(
      const double * __restrict__ Qinside, // Qinside[3+1]
      double * __restrict__ Qoutside, // Qoutside[3+1]
      const tarch::la::Vector<Dimensions,double>&  faceCentre,
      const tarch::la::Vector<Dimensions,double>&  volumeH,
      double                                       t,
      int                                          normal
    )  final;




    /**
     * If you hook into this routine, ensure the abstract base class
     * operation is still invoked.
     */
    void startGridConstructionStep() override;

    /**
     * If you hook into this routine, ensure the abstract base class
     * operation is still invoked.
     */
    void finishGridConstructionStep() override;



    /**
     * If you hook into this routine, ensure the abstract base class
     * operation is still invoked.
     */
    void startGridInitialisationStep() override;

    /**
     * If you hook into this routine, ensure the abstract base class
     * operation is still invoked.
     */
    void finishGridInitialisationStep() override;




    /**
     * If you hook into this routine, ensure the abstract base class
     * operation is still invoked.
     */
    void startTimeStep(
      double globalMinTimeStamp,
      double globalMaxTimeStamp,
      double globalMinTimeStepSize,
      double globalMaxTimeStepSize
    ) override;

    /**
     * If you hook into this routine, ensure the abstract base class
     * operation is still invoked.
     */
    void finishTimeStep() override;


    /**
     * If you hook into this routine, ensure the abstract base class
     * operation is still invoked.
     */
    void startPlottingStep(
      double globalMinTimeStamp,
      double globalMaxTimeStamp,
      double globalMinTimeStepSize,
      double globalMaxTimeStepSize
    ) override;

    /**
     * If you hook into this routine, ensure the abstract base class
     * operation is still invoked.
     */
    void finishPlottingStep() override;


    double getMaxMeshSize() const override;
    double getMinMeshSize() const override;
    
    /**
     * Inform about maximum eigenvalue of a patch
     *
     * The routine automatically computes the admissible time step size 
     * for the next time step. Is to be called per patch from the solver.
     *
     *
     * This operation is thread-safe.
     */
    void setMaximumEigenvalue( double value );

    SolverState  getSolverState() const;
    #if defined(OpenMPGPUOffloading)
    #pragma omp declare target
    #endif
    static constexpr int    NumberOfUnknowns           = 3;
    static constexpr int    NumberOfAuxiliaryVariables = 1;
    
    #if defined(OpenMPGPUOffloading)
    #pragma omp end declare target
    #endif

  protected:
    static tarch::logging::Log                  _log;
    static tarch::multicore::BooleanSemaphore   _sempahore;

    const int     _NumberOfFiniteVolumesPerAxisPerPatch;

    double     _timeStamp;
    double     _timeStepSize;
    double     _admissibleTimeStepSize;

    SolverState  _solverState;

    double     _maxH;
    double     _minH;

};


#endif