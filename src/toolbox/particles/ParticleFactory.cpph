#include "peano4/utils/Loop.h"

#include <random>


namespace {
  std::random_device rd;
  std::mt19937 e2(rd());
  std::uniform_real_distribution<> randomDist(0, 1);
}


template <class T>
std::vector<T*> toolbox::particles::createEquallySpacedParticles(double h, const peano4::datamanagement::VertexMarker& marker, bool roundDown, bool addNoise) {
  std::vector<T*> result;

  double continuousParticlesPerAxis = marker.h()(0) / h;
  int    particlesPerAxis           = static_cast<int>( std::round(continuousParticlesPerAxis) );
  continuousParticlesPerAxis -= particlesPerAxis;
  assertion(continuousParticlesPerAxis>=0.0);
  assertion(continuousParticlesPerAxis<=1.0);
  double randomDraw = randomDist(e2);
  if (not roundDown and randomDraw<continuousParticlesPerAxis) {
    particlesPerAxis++;
  }

  if (particlesPerAxis>0) {
    const double particleSpacing = marker.h()(0)/particlesPerAxis;

    const tarch::la::Vector<Dimensions,double> offset = marker.x() - marker.h()/2.0 + 0.5*tarch::la::Vector<Dimensions,double>(particleSpacing);

    dfor(k, particlesPerAxis) {
      tarch::la::Vector<Dimensions,double> x = offset + particleSpacing * tarch::la::convertScalar<double>(k);
      T* newParticle = new T();
      #if PeanoDebug>0
      newParticle->setDebugX( marker.x() );
      newParticle->setDebugH( marker.h() );
      #endif
      if (addNoise) {
        for (int d=0; d<Dimensions; d++) {
          x(d) += (randomDist(e2) - 0.5) * particleSpacing;
        }
      }
      newParticle->setX(x);
      newParticle->setCutOffRadius( 0.9*tarch::la::min(marker.h()) );
      newParticle->setMoveState( T::MoveState::New );
      result.push_back(newParticle);
    }
  }

  return result;
}
