#include "tarch/Assertions.h"
#include "tarch/compiler/CompilerSpecificSettings.h"


template<class Data, bool CreateCopiesOfSentData, class SendReceiveTaskType, class VectorContainer>
tarch::logging::Log  peano::heap::AggregationBoundaryDataExchanger<Data,CreateCopiesOfSentData, SendReceiveTaskType,VectorContainer>::_log( "peano::heap::AggregationBoundaryDataExchanger" );



template<class Data, bool CreateCopiesOfSentData, class SendReceiveTaskType, class VectorContainer>
peano::heap::AggregationBoundaryDataExchanger<Data,CreateCopiesOfSentData, SendReceiveTaskType,VectorContainer>::AggregationBoundaryDataExchanger():
  BoundaryDataExchanger<Data,SendReceiveTaskType,VectorContainer>(),
  _numberOfSentMessages(0) {
}


template<class Data, bool CreateCopiesOfSentData, class SendReceiveTaskType, class VectorContainer>
peano::heap::AggregationBoundaryDataExchanger<Data,CreateCopiesOfSentData, SendReceiveTaskType,VectorContainer>::AggregationBoundaryDataExchanger(
  const std::string& identifier,
  int metaDataTag, int dataTag,
  int rank
):
  BoundaryDataExchanger<Data,SendReceiveTaskType,VectorContainer>(identifier,metaDataTag,dataTag,rank),
  _numberOfSentMessages(0) {
}


template<class Data, bool CreateCopiesOfSentData, class SendReceiveTaskType, class VectorContainer>
peano::heap::AggregationBoundaryDataExchanger<Data,CreateCopiesOfSentData, SendReceiveTaskType,VectorContainer>::~AggregationBoundaryDataExchanger() {
}


template<class Data, bool CreateCopiesOfSentData, class SendReceiveTaskType, class VectorContainer>
bool peano::heap::AggregationBoundaryDataExchanger<Data,CreateCopiesOfSentData, SendReceiveTaskType,VectorContainer>::dataExchangerCommunicatesInBackground() const {
  return true;
}


template<class Data, bool CreateCopiesOfSentData, class SendReceiveTaskType, class VectorContainer>
int peano::heap::AggregationBoundaryDataExchanger<Data,CreateCopiesOfSentData, SendReceiveTaskType,VectorContainer>::getNumberOfSentMessages() const {
  return _numberOfSentMessages;
}


template<class Data, bool CreateCopiesOfSentData, class SendReceiveTaskType, class VectorContainer>
void peano::heap::AggregationBoundaryDataExchanger<Data,CreateCopiesOfSentData, SendReceiveTaskType,VectorContainer>::postprocessStartToSendData() {
  _numberOfSentMessages = 0;

  assertion( Base::_sendTasks.empty() );

  _aggregatedSendData.clear();
}


template<class Data, bool CreateCopiesOfSentData, class SendReceiveTaskType, class VectorContainer>
void peano::heap::AggregationBoundaryDataExchanger<Data,CreateCopiesOfSentData, SendReceiveTaskType,VectorContainer>::postprocessFinishedToSendData() {
  assertion( Base::_sendTasks.empty() );

  Base::_sendTasks.push_back( SendReceiveTaskType() );

  Base::_sendTasks.back()._metaInformation.setLength( _aggregatedSendData.size() );
  Base::_sendTasks.back()._rank = Base::_rank;
  Base::_sendTasks.back().sendDataDirectlyFromBuffer( _aggregatedSendData.data() );

  if (!_aggregatedSendData.empty()) {
    Base::_sendTasks.back().triggerSend(Base::_dataTag);
  }
  Base::_sendTasks.back()._metaInformation.send(Base::_rank, Base::_metaDataTag, true, SendHeapMetaDataBlocking);

  logInfo( "postprocessFinishedToSendData()", "sent out one big message of size " << _aggregatedSendData.data() << " which aggregates " << _numberOfSentMessages << " message(s)");
}


template<class Data, bool CreateCopiesOfSentData, class SendReceiveTaskType, class VectorContainer>
void peano::heap::AggregationBoundaryDataExchanger<Data,CreateCopiesOfSentData, SendReceiveTaskType,VectorContainer>::handleAndQueueReceivedTask( const SendReceiveTaskType&  receivedTask ) {
  SendReceiveTaskType localTask( receivedTask );
  localTask.triggerReceive(Base::_dataTag);
  if (localTask._metaInformation.getLength() > 0) {
    MPI_Wait(&(localTask._request), MPI_STATUS_IGNORE);
  }
  logInfo( "handleAndQueueReceivedTask(...)", "received out one big message of size " << localTask._metaInformation.getLength() );

  int index = 0;
  while (index<receivedTask._metaInformation.getLength()) {
	int sizeOfNextMessage = localTask._data[index];
	index++;
	assertion(sizeOfNextMessage>=0);

    Base::_receiveTasks[Base::_currentReceiveBuffer].push_back( SendReceiveTaskType() );
    Base::_receiveTasks[Base::_currentReceiveBuffer].back()._metaInformation.setLength(sizeOfNextMessage);
    if (sizeOfNextMessage>0) {
      Base::_receiveTasks[Base::_currentReceiveBuffer].back().data = new Data[sizeOfNextMessage];
      for (int i=0; i<sizeOfNextMessage; i++) {
   		Base::_receiveTasks[Base::_currentReceiveBuffer].back().data[i] = localTask._data[index];
   		index++;
      }
    }
  }

  logInfo( "handleAndQueueReceivedTask(...)", "decomposed message into " << Base::_receiveTasks[Base::_currentReceiveBuffer].size() << " message(s)" );

  localTask.freeMemory();
}


template<class Data, bool CreateCopiesOfSentData, class SendReceiveTaskType, class VectorContainer>
void peano::heap::AggregationBoundaryDataExchanger<Data,CreateCopiesOfSentData, SendReceiveTaskType,VectorContainer>::handleAndQueueSendTask(
  const SendReceiveTaskType&   sendTask,
  const Data* const            data
) {
  logTraceIn( "handleAndQueueSendTask(...)" );

  _numberOfSentMessages++;

  _aggregatedSendData.push_back(Base::_sendTasks.back()._metaInformation.getLength());

  for (int i=0; i<Base::_sendTasks.back()._metaInformation.getLength(); i++) {
    _aggregatedSendData.push_back(data[i]);
  }

  logTraceOut( "handleAndQueueSendTask(...)" );
}
