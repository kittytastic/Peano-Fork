#include "tarch/Assertions.h"
#include "tarch/compiler/CompilerSpecificSettings.h"


template<class Data, bool CreateCopiesOfSentData, class SendReceiveTaskType, class VectorContainer>
tarch::logging::Log  peano::heap::AggregationBoundaryDataExchanger<Data,CreateCopiesOfSentData, SendReceiveTaskType,VectorContainer>::_log( "peano::heap::AggregationBoundaryDataExchanger" );



template<class Data, bool CreateCopiesOfSentData, class SendReceiveTaskType, class VectorContainer>
peano::heap::AggregationBoundaryDataExchanger<Data,CreateCopiesOfSentData, SendReceiveTaskType,VectorContainer>::AggregationBoundaryDataExchanger():
  BoundaryDataExchanger<Data,SendReceiveTaskType,VectorContainer>(),
  _numberOfSentMessages(0) {
}


template<class Data, bool CreateCopiesOfSentData, class SendReceiveTaskType, class VectorContainer>
peano::heap::AggregationBoundaryDataExchanger<Data,CreateCopiesOfSentData, SendReceiveTaskType,VectorContainer>::AggregationBoundaryDataExchanger(
  const std::string& identifier,
  int metaDataTag, int dataTag,
  int rank
):
  BoundaryDataExchanger<Data,SendReceiveTaskType,VectorContainer>(identifier,metaDataTag,dataTag,rank),
  _numberOfSentMessages(0) {
}


template<class Data, bool CreateCopiesOfSentData, class SendReceiveTaskType, class VectorContainer>
peano::heap::AggregationBoundaryDataExchanger<Data,CreateCopiesOfSentData, SendReceiveTaskType,VectorContainer>::~AggregationBoundaryDataExchanger() {
}


template<class Data, bool CreateCopiesOfSentData, class SendReceiveTaskType, class VectorContainer>
bool peano::heap::AggregationBoundaryDataExchanger<Data,CreateCopiesOfSentData, SendReceiveTaskType,VectorContainer>::dataExchangerCommunicatesInBackground() const {
  return true;
}


template<class Data, bool CreateCopiesOfSentData, class SendReceiveTaskType, class VectorContainer>
int peano::heap::AggregationBoundaryDataExchanger<Data,CreateCopiesOfSentData, SendReceiveTaskType,VectorContainer>::getNumberOfSentMessages() const {
  return _numberOfSentMessages>0 ? 1 : 0;
}


template<class Data, bool CreateCopiesOfSentData, class SendReceiveTaskType, class VectorContainer>
void peano::heap::AggregationBoundaryDataExchanger<Data,CreateCopiesOfSentData, SendReceiveTaskType,VectorContainer>::postprocessStartToSendData() {
  _numberOfSentMessages = 0;

  assertion( Base::_sendTasks.empty() );

  _aggregatedSendData.clear();
  // Create place holder. Will later be set to number of encoded messages
  _aggregatedSendData.push_back(0);

  const int BufferToBeUnpacked = 1-Base::_currentReceiveBuffer;

  assertion( Base::_receiveTasks[BufferToBeUnpacked].size()<=1 );

  if (Base::_receiveTasks[BufferToBeUnpacked].size()>0) {
	// Take the single (aggregated) message, store it in a local variable
	// and then clear the deploy buffer, as we'll put the messages as torn
	// apart into this one.
    SendReceiveTaskType localTask = Base::_receiveTasks[BufferToBeUnpacked].front();
    Base::_receiveTasks[BufferToBeUnpacked].clear();

    int index = 0;
    int totalNumberOfMessages = static_cast<int>(localTask._data[index]);
	index++;

    #ifdef Asserts
    logInfo( "postprocessStartToSendData(...)",
      "found one big message(s) from rank " << Base::_rank << " in local deploy queue which encodes " <<
	  totalNumberOfMessages << " message(s). There's " << Base::_receiveTasks[1-BufferToBeUnpacked].size() << " big message(s) remaining in the receive queue"
    );
    #endif

    for (int j=0; j<totalNumberOfMessages; j++) {
      int sizeOfNextMessage = static_cast<int>(localTask._data[index]);
  	  index++;
  	  assertion(sizeOfNextMessage>=0);

      Base::_receiveTasks[BufferToBeUnpacked].push_back( SendReceiveTaskType() );
      Base::_receiveTasks[BufferToBeUnpacked].back()._metaInformation.setLength(0);
      if (sizeOfNextMessage>0) {
        Base::_receiveTasks[BufferToBeUnpacked].back()._data = new Data[sizeOfNextMessage];
        for (int i=0; i<static_cast<int>(sizeOfNextMessage); i++) {
     		Base::_receiveTasks[BufferToBeUnpacked].back()._data[i] = localTask._data[index];
     		index++;
        }
      }
      logDebug( "postprocessStartToSendData(...)", "message terminating after " <<
        index << " entries did contain " << sizeOfNextMessage << " data entries"
      );
    }

    #ifdef Asserts
    logInfo( "postprocessStartToSendData(...)", "decomposed message into " << Base::_receiveTasks[BufferToBeUnpacked].size() << " deploy message(s)" );
    #endif

    // Ensure that we have got exactly the right number of messages in the
    // deploy queue
    assertionEquals(static_cast<int>(Base::_receiveTasks[BufferToBeUnpacked].size()), totalNumberOfMessages);

    // We are done, so free the memory of the aggregated message. It is now
    // extracted/torn apart completely.
    localTask.freeMemory();
  }
  else {
    #ifdef Asserts
    logInfo( "postprocessStartToSendData(...)",
      "no received data has been found in deploy queue. There are " << Base::_receiveTasks[1-BufferToBeUnpacked].size() << " big message(s) remaining in the receive queue"
    );
    #endif
  }
}

//Es gibt keine Copies

template<class Data, bool CreateCopiesOfSentData, class SendReceiveTaskType, class VectorContainer>
void peano::heap::AggregationBoundaryDataExchanger<Data,CreateCopiesOfSentData, SendReceiveTaskType,VectorContainer>::postprocessFinishedToSendData() {
  assertion( Base::_sendTasks.empty() );

  logInfo( "postprocessFinishedToSendData()",
    "send out one big message to rank " << Base::_rank << " which aggregates " << _numberOfSentMessages <<
	" message(s) and has " << _aggregatedSendData.size() << " entries in total"
  );

  _aggregatedSendData[0] = _numberOfSentMessages;

// too late

  Base::_sendTasks.push_back( SendReceiveTaskType() );

  Base::_sendTasks.back()._metaInformation.setLength( _aggregatedSendData.size() );
  Base::_sendTasks.back()._rank = Base::_rank;

  if (!_aggregatedSendData.empty()) {
    Base::_sendTasks.back().sendDataDirectlyFromBuffer( _aggregatedSendData.data() );
    Base::_sendTasks.back().triggerSend(Base::_dataTag);
  }
  Base::_sendTasks.back()._metaInformation.send(Base::_rank, Base::_metaDataTag, true, SendHeapMetaDataBlocking);
}


template<class Data, bool CreateCopiesOfSentData, class SendReceiveTaskType, class VectorContainer>
void peano::heap::AggregationBoundaryDataExchanger<Data,CreateCopiesOfSentData, SendReceiveTaskType,VectorContainer>::handleAndQueueReceivedTask( const SendReceiveTaskType&  receivedTask ) {
  #ifdef Asserts
  logInfo( "handleAndQueueReceivedTask()",
    "received message from rank " << Base::_rank << " which contains " << receivedTask._metaInformation.getLength() << " entries in total. Enqueue to receive actual data behind envelope"
  );
  #endif

  Base::_receiveTasks[Base::_currentReceiveBuffer].push_back( receivedTask );
  if (Base::_receiveTasks[Base::_currentReceiveBuffer].back()._metaInformation.getLength() > 0) {
    Base::_receiveTasks[Base::_currentReceiveBuffer].back().triggerReceive(Base::_dataTag);
  }
}


template<class Data, bool CreateCopiesOfSentData, class SendReceiveTaskType, class VectorContainer>
void peano::heap::AggregationBoundaryDataExchanger<Data,CreateCopiesOfSentData, SendReceiveTaskType,VectorContainer>::handleAndQueueSendTask(
  const SendReceiveTaskType&   sendTask,
  const Data* const            data
) {
  logTraceIn( "handleAndQueueSendTask(...)" );

  _numberOfSentMessages++;

  assertion( Base::_sendTasks.empty() );

  logDebug(
     "handleAndQueueReceivedTask(...)", "attach " << _numberOfSentMessages << "th message to aggregated data. Message carries " <<
	 sendTask._metaInformation.getLength() << " entries. Aggregated message so far has " << _aggregatedSendData.size() << " entries");

  _aggregatedSendData.push_back(static_cast<Data>(sendTask._metaInformation.getLength()));

  for (int i=0; i<sendTask._metaInformation.getLength(); i++) {
    _aggregatedSendData.push_back(data[i]);
  }

  logTraceOut( "handleAndQueueSendTask(...)" );
}
