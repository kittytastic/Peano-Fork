#include "tarch/Assertions.h"
#include "tarch/logging/Log.h"
#include "exahype2/fv/Generic.h"
#include "exahype2/PatchUtils.h"
#include "exahype2/NonCriticalAssertions.h"


template <typename Flux, typename Eigenvalues>
void exahype2::fv::gpu::applyRusanovToPatch_FaceLoops(
  Flux                                         flux,
  Eigenvalues                                  eigenvalues,
  const tarch::la::Vector<Dimensions,double>&  patchCentre,
  const tarch::la::Vector<Dimensions,double>&  patchSize,
  double                                       t,
  double                                       dt,
  int                                          numberOfVolumesPerAxisInPatch,
  int                                          unknowns,
  double                                       Qin[],
  double                                       Qout[]
) {
  ::exahype2::fv::gpu::applyRusanovToPatch_FaceLoops(
    flux,
	[] (
	  double * __restrict__ Q,
	  double                                       gradQ[][Dimensions],
	  const tarch::la::Vector<Dimensions,double>&  faceCentre,
	  const tarch::la::Vector<Dimensions,double>&  volumeH,
	  double                                       t,
	  double                                       dt,
	  int                                          normal,
	  double * __restrict__ BgradQ
	) -> void {},
    eigenvalues,
    patchCentre,
    patchSize,
    t,
    dt,
    numberOfVolumesPerAxisInPatch,
    unknowns,
    Qin, Qout
  );
}



template< typename Flux, typename NCP, typename MaxEigenvalue>
void exahype2::fv::gpu::splitRusanov1d(
        Flux flux,
        NCP  nonconservativeProduct,
        MaxEigenvalue maxEigenvalues,
        double * __restrict__ QL,
        double * __restrict__ QR,
        const tarch::la::Vector<Dimensions,double>&  x,
        double                                       dx,
        double                                       t,
        double                                       dt,
        int                                          normal,
        int                                          unknowns,
        int                                          auxiliaryVariables,
        double * __restrict__ FL,
        double * __restrict__ FR
)  {
  #if !defined(GPUOffloading)
  assertion(normal>=0);
  assertion(normal<Dimensions);
  #endif

  double fluxFL[unknowns];
  double fluxFR[unknowns];
  flux(QL,x,dx,t,dt,normal,fluxFL);
  flux(QR,x,dx,t,dt,normal,fluxFR);

  double Qaverage[unknowns+auxiliaryVariables];
  double gradQ[unknowns+auxiliaryVariables][Dimensions];
  for (int unknown=0; unknown<unknowns+auxiliaryVariables; unknown++) {
    for (int d=0; d<Dimensions; d++) {
      gradQ[unknown][d] = 0.0;
    }
    Qaverage[unknown] = 0.5 * QL[unknown] + 0.5 * QR[unknown];
    gradQ[unknown][normal] = QR[unknown] - QL[unknown];
  }
  double fluxnonconservativeProduct[unknowns];
  // It is important that we initialise these guys with 0, as
  // ncp might nop and we hence might add garbage
  for (int i=0; i<unknowns; i++) {
    fluxnonconservativeProduct[i] = 0.0;
  }
  nonconservativeProduct(Qaverage,gradQ,x,dx,t,dt,normal,fluxnonconservativeProduct);

  double lambdaMaxL = MaxEigenvalue(QL,x,dx,t,dt,normal);
  double lambdaMaxR = MaxEigenvalue(QR,x,dx,t,dt,normal);
  double lambdaMax = std::max(lambdaMaxL,lambdaMaxR);

  for (int unknown=0; unknown<unknowns; unknown++) {
    FL[unknown] = 0.5 * fluxFL[unknown] + 0.5 * fluxFR[unknown] - 0.5 * lambdaMax * (QR[unknown] - QL[unknown]) - 0.5 * fluxnonconservativeProduct[unknown];
    FR[unknown] = 0.5 * fluxFL[unknown] + 0.5 * fluxFR[unknown] - 0.5 * lambdaMax * (QR[unknown] - QL[unknown]) + 0.5 * fluxnonconservativeProduct[unknown];
    #if !defined(GPUOffloading)
    nonCriticalAssertion6(FL[unknown]==FL[unknown], fluxFL[unknown], fluxFR[unknown], lambdaMax, QR[unknown], QL[unknown], fluxnonconservativeProduct[unknown]);
    nonCriticalAssertion6(FR[unknown]==FR[unknown], fluxFL[unknown], fluxFR[unknown], lambdaMax, QR[unknown], QL[unknown], fluxnonconservativeProduct[unknown]);
    #endif
  }
}


template <typename Flux, typename NCP, typename MaxEigenvalue>
void exahype2::fv::gpu::applyRusanovToPatch_FaceLoops(
  Flux                                         flux,
  NCP                                          nonconservativeProduct,
  MaxEigenvalue                                maxEigenvalue,
  const tarch::la::Vector<Dimensions,double>&  patchCentre,
  const tarch::la::Vector<Dimensions,double>&  patchSize,
  double                                       t,
  double                                       dt,
  int                                          numberOfVolumesPerAxisInPatch,
  int                                          unknowns,
  int                                          auxiliaryVariables,
  double                                       Qin[],
  double                                       Qout[]
) {

  #if Dimensions==2
  {
    const double volumeH = ::exahype2::getVolumeLength(patchSize, numberOfVolumesPerAxisInPatch);

    for (int shift=0; shift<1; shift++)
    #if defined(SharedOMP)
    #pragma omp parallel for collapse(2)
    #endif
    for (int x=shift; x<=numberOfVolumesPerAxisInPatch; x+=2) {
      for (int y=0; y<numberOfVolumesPerAxisInPatch; y++) {
   	    double numericalFluxL[unknowns]; // helper out variable
   	    double numericalFluxR[unknowns]; // helper out variable

        const int leftVoxelInPreimage  =  x
                                       + (y+1) * (2 + numberOfVolumesPerAxisInPatch);
        const int rightVoxelInPreimage =  x+1
                                       + (y+1) * (2 + numberOfVolumesPerAxisInPatch);

        const int leftVoxelInImage     = x-1
                                       + y * numberOfVolumesPerAxisInPatch;
        const int rightVoxelInImage    = x
                                       + y * numberOfVolumesPerAxisInPatch;
  
        // This line gives
        //
        // during IPA pass: cp
        // lto1: internal compiler error: Segmentation fault
        //
        // so I have to replace it by a manual construction of the vector
        // circumnavigating the copy constructor.
        //
        // tarch::la::Vector<Dimensions,double> volumeX = patchCentre - 0.5 * patchSize;
        tarch::la::Vector<Dimensions,double> volumeX;
        volumeX(0) = patchCentre(0) - 0.5 * patchSize(0);
        volumeX(1) = patchCentre(1) - 0.5 * patchSize(1);

        volumeX(0) += x * volumeH;
        volumeX(1) += (y+0.5) * volumeH;

        gpu::splitRusanov1d(
          flux, nonconservativeProduct, maxEigenvalue,
          Qin + leftVoxelInPreimage*(unknowns+auxiliaryVariables),   // QL
          Qin + rightVoxelInPreimage*(unknowns+auxiliaryVariables),  // QR
          volumeX, volumeH, t, dt, 0, //  last argument = normal
          unknowns,
          numericalFluxL, numericalFluxR
        );

        for (int unknown=0; unknown<unknowns; unknown++) {
          if (x>0) {
            Qout[ leftVoxelInImage*(unknowns+auxiliaryVariables)+unknown ] -= dt / volumeH * numericalFluxL[unknown];
            #if !defined(GPUOffloading)
            nonCriticalAssertion4(Qout[ leftVoxelInImage*(unknowns+auxiliaryVariables)+unknown ]==Qout[ leftVoxelInImage*(unknowns+auxiliaryVariables)+unknown ], dt, volumeH, numericalFluxL[unknown], unknown);
            #endif
          }
          if (x<numberOfVolumesPerAxisInPatch) {
            Qout[ rightVoxelInImage*(unknowns+auxiliaryVariables)+unknown ] += dt / volumeH * numericalFluxR[unknown];
            #if !defined(GPUOffloading)
            nonCriticalAssertion4(Qout[ rightVoxelInImage*(unknowns+auxiliaryVariables)+unknown ]==Qout[ rightVoxelInImage*(unknowns+auxiliaryVariables)+unknown ], dt, volumeH, numericalFluxR[unknown], unknown);
            #endif
          }
        }
      }
    }

    for (int shift=0; shift<1; shift++)
    #if defined(SharedOMP)
    #pragma omp parallel for collapse(2)
    #endif
    for (int x=0; x<numberOfVolumesPerAxisInPatch; x++) {
      for (int y=0; y<=numberOfVolumesPerAxisInPatch; y+=2) {
   	    double numericalFluxL[unknowns]; // helper out variable
   	    double numericalFluxR[unknowns]; // helper out variable

        const int lowerVoxelInPreimage =  x+1
                                       +  y * (2 + numberOfVolumesPerAxisInPatch);
        const int upperVoxelInPreimage =  x+1
                                       + (y+1) * (2 + numberOfVolumesPerAxisInPatch);
   
        const int lowerVoxelInImage    = x
                                       + (y-1) * numberOfVolumesPerAxisInPatch;
        const int upperVoxelInImage    = x
                                       + y * numberOfVolumesPerAxisInPatch;

        tarch::la::Vector<Dimensions,double> volumeX; 
        volumeX(0) = patchCentre(0) - 0.5 * patchSize(0);
        volumeX(1) = patchCentre(1) - 0.5 * patchSize(1);

        volumeX(0) += (x+0.5) * volumeH;
        volumeX(1) += y * volumeH;
 
        gpu::splitRusanov1d(
          flux, nonconservativeProduct, maxEigenvalue,
          Qin + lowerVoxelInPreimage*(unknowns+auxiliaryVariables),
          Qin + upperVoxelInPreimage*(unknowns+auxiliaryVariables),
          volumeX, volumeH, t, dt, 1, //  last argument = normala
          unknowns,
          numericalFluxL, numericalFluxR
        );
  
        for (int unknown=0; unknown<unknowns; unknown++) {
          if (y>0) {
            Qout[ lowerVoxelInImage*(unknowns+auxiliaryVariables)+unknown ] -= dt / volumeH * numericalFluxL[unknown];
            #if !defined(GPUOffloading)
            nonCriticalAssertion4(Qout[ lowerVoxelInImage*(unknowns+auxiliaryVariables)+unknown ]==Qout[ lowerVoxelInImage*(unknowns+auxiliaryVariables)+unknown ], dt, volumeH, numericalFluxL[unknown], unknown);
            #endif
          }
          if (y<numberOfVolumesPerAxisInPatch) {
            Qout[ upperVoxelInImage*(unknowns+auxiliaryVariables)+unknown ] += dt / volumeH * numericalFluxR[unknown];
            #if !defined(GPUOffloading)
            nonCriticalAssertion4(Qout[ upperVoxelInImage*(unknowns+auxiliaryVariables)+unknown ]==Qout[ upperVoxelInImage*(unknowns+auxiliaryVariables)+unknown ], dt, volumeH, numericalFluxR[unknown], unknown);
            #endif
          }
        }
      }
    }
  }
  #else

  double patchCentreData[] = {patchCentre(0), patchCentre(1), patchCentre(2)};
  double patchSizeData[]   = {patchSize(0),   patchSize(1),   patchSize(2)};
  tarch::la::Vector<Dimensions,double> volumeHTmp = exahype2::getVolumeSize(patchSize, numberOfVolumesPerAxisInPatch);
  double volumeHData[] = {volumeHTmp(0), volumeHTmp(1), volumeHTmp(2)};
  //Not sure if the following is required:
  //#pragma omp target map(to:volumeHData,patchCentreData,patchSizeData,t,dt,numberOfVolumesPerAxisInPatch,unknowns,Qin[0:unknowns*(numberOfVolumesPerAxisInPatch+2)*(numberOfVolumesPerAxisInPatch+2)*(numberOfVolumesPerAxisInPatch+2)]) map(from:Qout[0:unknowns*(numberOfVolumesPerAxisInPatch)*(numberOfVolumesPerAxisInPatch)*(numberOfVolumesPerAxisInPatch)])
  #if defined(GPUOffloading)
  #pragma omp target map(to:volumeHData,patchCentreData,patchSizeData,t,dt,numberOfVolumesPerAxisInPatch,unknowns,Qin) map(from:Qout)
  #endif
  {
    tarch::la::Vector<3,double>  patchCentre(patchCentreData);
    tarch::la::Vector<3,double>  patchSize(patchSizeData);
    tarch::la::Vector<3,double> volumeH(volumeHData);

    double numericalFluxL[unknowns]; // helper out variable
    double numericalFluxR[unknowns]; // helper out variable

    #pragma omp parallel for
    for (int z=0; z<numberOfVolumesPerAxisInPatch; z++)
    for (int y=0; y<numberOfVolumesPerAxisInPatch; y++)
    for (int x=0; x<=numberOfVolumesPerAxisInPatch; x++) {
      const int leftVoxelInPreimage  =  x
                                     + (y+1) * (2 + numberOfVolumesPerAxisInPatch)
                                     + (z+1) * (2 + numberOfVolumesPerAxisInPatch) * (2 + numberOfVolumesPerAxisInPatch);
      const int rightVoxelInPreimage =  x+1
                                     + (y+1) * (2 + numberOfVolumesPerAxisInPatch)
                                     + (z+1) * (2 + numberOfVolumesPerAxisInPatch) * (2 + numberOfVolumesPerAxisInPatch);

      const int leftVoxelInImage     = x-1
                                     + y * numberOfVolumesPerAxisInPatch
                                     + z * numberOfVolumesPerAxisInPatch * numberOfVolumesPerAxisInPatch;
      const int rightVoxelInImage    = x
                                     + y * numberOfVolumesPerAxisInPatch
                                     + z * numberOfVolumesPerAxisInPatch * numberOfVolumesPerAxisInPatch;

      // This line gives
      //
      // during IPA pass: cp
      // lto1: internal compiler error: Segmentation fault
      //
      // so I have to replace it by a manual construction of the vector
      // circumnavigating the copy constructor.
      //
      // tarch::la::Vector<Dimensions,double> volumeX = patchCentre - 0.5 * patchSize;
      tarch::la::Vector<Dimensions,double> volumeX;
      volumeX(0) = patchCentre(0) - 0.5 * patchSize(0);
      volumeX(1) = patchCentre(1) - 0.5 * patchSize(1);
      volumeX(2) = patchCentre(2) - 0.5 * patchSize(2);

      volumeX(0) += x * volumeH(0);
      volumeX(1) += (y+0.5) * volumeH(1);
      volumeX(2) += (z+0.5) * volumeH(2);

      gpu::splitRusanov1d(
        flux, nonconservativeProduct, maxEigenvalue,
        Qin + leftVoxelInPreimage*(unknowns+auxiliaryVariables),   // QL
        Qin + rightVoxelInPreimage*(unknowns+auxiliaryVariables),  // QR
        volumeX, volumeH(0), t, dt, 0, //  last argument = normal
        unknowns,
        numericalFluxL, numericalFluxR
      );

      for (int unknown=0; unknown<unknowns; unknown++) {
        if (x>0) {
          Qout[ leftVoxelInImage*(unknowns+auxiliaryVariables)+unknown ] -= dt / volumeH(0) * numericalFluxL[unknown];
        }
        if (x<numberOfVolumesPerAxisInPatch) {
          Qout[ rightVoxelInImage*(unknowns+auxiliaryVariables)+unknown ] += dt / volumeH(0) * numericalFluxR[unknown];
        }
      }
    }

    #pragma omp parallel for
    for (int z=0; z<numberOfVolumesPerAxisInPatch; z++)
    for (int y=0; y<=numberOfVolumesPerAxisInPatch; y++)
    for (int x=0; x<numberOfVolumesPerAxisInPatch; x++) {
      const int lowerVoxelInPreimage =  x+1
                                     +  y * (2 + numberOfVolumesPerAxisInPatch)
                                     + (z+1) * (2 + numberOfVolumesPerAxisInPatch) * (2 + numberOfVolumesPerAxisInPatch);
      const int upperVoxelInPreimage =  x+1
                                     + (y+1) * (2 + numberOfVolumesPerAxisInPatch)
                                     + (z+1) * (2 + numberOfVolumesPerAxisInPatch) * (2 + numberOfVolumesPerAxisInPatch);

      const int lowerVoxelInImage    = x
                                     + (y-1) * numberOfVolumesPerAxisInPatch
                                     + z * numberOfVolumesPerAxisInPatch * numberOfVolumesPerAxisInPatch;
      const int upperVoxelInImage    = x
                                     + y * numberOfVolumesPerAxisInPatch
                                     + z * numberOfVolumesPerAxisInPatch * numberOfVolumesPerAxisInPatch;


      // This line gives
      //
      // during IPA pass: cp
      // lto1: internal compiler error: Segmentation fault
      //
      // so I have to replace it by a manual construction of the vector
      // circumnavigating the copy constructor.
      //
      // tarch::la::Vector<Dimensions,double> volumeX = patchCentre - 0.5 * patchSize;
      tarch::la::Vector<Dimensions,double> volumeX;
      volumeX(0) = patchCentre(0) - 0.5 * patchSize(0);
      volumeX(1) = patchCentre(1) - 0.5 * patchSize(1);
      volumeX(2) = patchCentre(2) - 0.5 * patchSize(2);

      volumeX(0) += (x+0.5) * volumeH(0);
      volumeX(1) += y * volumeH(1);
      volumeX(2) += (z+0.5) * volumeH(2);

      gpu::splitRusanov1d(
        flux, nonconservativeProduct, maxEigenvalue,
        Qin + lowerVoxelInPreimage*(unknowns+auxiliaryVariables),
        Qin + upperVoxelInPreimage*(unknowns+auxiliaryVariables),
        volumeX, volumeH(0), t, dt, 1, //  last argument = normal
        unknowns,
        numericalFluxL, numericalFluxR
      );

      for (int unknown=0; unknown<unknowns; unknown++) {
        if (y>0) {
          Qout[ lowerVoxelInImage*(unknowns+auxiliaryVariables)+unknown ] -= dt / volumeH(0) * numericalFluxL[unknown];
        }
        if (y<numberOfVolumesPerAxisInPatch) {
          Qout[ upperVoxelInImage*(unknowns+auxiliaryVariables)+unknown ] += dt / volumeH(0) * numericalFluxR[unknown];
        }
      }
    }

    #pragma omp parallel for
    for (int z=0; z<=numberOfVolumesPerAxisInPatch; z++)
    for (int y=0; y<numberOfVolumesPerAxisInPatch; y++)
    for (int x=0; x<numberOfVolumesPerAxisInPatch; x++) {
      const int lowerVoxelInPreimage =  x+1
                                     + (y+1) * (2 + numberOfVolumesPerAxisInPatch)
                                     +  z * (2 + numberOfVolumesPerAxisInPatch) * (2 + numberOfVolumesPerAxisInPatch);
      const int upperVoxelInPreimage =  x+1
                                     + (y+1) * (2 + numberOfVolumesPerAxisInPatch)
                                     + (z+1) * (2 + numberOfVolumesPerAxisInPatch) * (2 + numberOfVolumesPerAxisInPatch);

      const int lowerVoxelInImage    = x
                                     + y * numberOfVolumesPerAxisInPatch
                                     + (z-1) * numberOfVolumesPerAxisInPatch * numberOfVolumesPerAxisInPatch;
      const int upperVoxelInImage    = x
                                     + y * numberOfVolumesPerAxisInPatch
                                     + z * numberOfVolumesPerAxisInPatch * numberOfVolumesPerAxisInPatch;

      // This line gives
      //
      // during IPA pass: cp
      // lto1: internal compiler error: Segmentation fault
      //
      // so I have to replace it by a manual construction of the vector
      // circumnavigating the copy constructor.
      //
      // tarch::la::Vector<Dimensions,double> volumeX = patchCentre - 0.5 * patchSize;
      tarch::la::Vector<Dimensions,double> volumeX;
      volumeX(0) = patchCentre(0) - 0.5 * patchSize(0);
      volumeX(1) = patchCentre(1) - 0.5 * patchSize(1);
      volumeX(2) = patchCentre(2) - 0.5 * patchSize(2);

      volumeX(0) += (x+0.5) * volumeH(0);
      volumeX(1) += (y+0.5) * volumeH(1);
      volumeX(2) += z * volumeH(2);

      gpu::splitRusanov1d(
        flux, nonconservativeProduct, maxEigenvalue,
        Qin + lowerVoxelInPreimage*(unknowns+auxiliaryVariables),
        Qin + upperVoxelInPreimage*(unknowns+auxiliaryVariables),
        volumeX, volumeH(0), t, dt, 2, //  last argument = normal
        unknowns,
        numericalFluxL, numericalFluxR
      );

      for (int unknown=0; unknown<unknowns; unknown++) {
        if (z>0) {
          Qout[ lowerVoxelInImage*(unknowns+auxiliaryVariables)+unknown ] -= dt / volumeH(0) * numericalFluxL[unknown];
        }
        if (z<numberOfVolumesPerAxisInPatch) {
          Qout[ upperVoxelInImage*(unknowns+auxiliaryVariables)+unknown ] += dt / volumeH(0) * numericalFluxR[unknown];
        }
      }
    }
  }
  #endif

}
