#include "tarch/logging/Log.h"
#include "../PatchUtils.h"


template <typename Flux, typename Eigenvalues>
void exahype2::fv::gpu::applyRusanovToPatch_FaceLoops(
  Flux                                         flux,
  Eigenvalues                                  eigenvalues,
  const tarch::la::Vector<Dimensions,double>&  patchCentre,
  const tarch::la::Vector<Dimensions,double>&  patchSize,
  double                                       t,
  double                                       dt,
  int                                          numberOfVolumesPerAxisInPatch,
  int                                          unknowns,
  double                                       Qin[],
  double                                       Qout[]
) {
  ::exahype2::fv::gpu::applyRusanovToPatch_FaceLoops(
    flux,
	[] (
	  double                                       Q[],
	  double                                       gradQ[][Dimensions],
	  const tarch::la::Vector<Dimensions,double>&  faceCentre,
	  const tarch::la::Vector<Dimensions,double>&  volumeH,
	  double                                       t,
	  double                                       dt,
	  int                                          normal,
	  double                                       BgradQ[]
	) -> void {},
    eigenvalues,
    patchCentre,
    patchSize,
    t,
    dt,
    numberOfVolumesPerAxisInPatch,
    unknowns,
    Qin, Qout
  );
}


template <typename Flux, typename NCP, typename Eigenvalues>
void exahype2::fv::gpu::applyRusanovToPatch_FaceLoops(
  Flux                                         flux,
  NCP                                          nonconservativeProduct,
  Eigenvalues                                  eigenvalues,
  const tarch::la::Vector<Dimensions,double>&  patchCentre,
  const tarch::la::Vector<Dimensions,double>&  patchSize,
  double                                       t,
  double                                       dt,
  int                                          numberOfVolumesPerAxisInPatch,
  int                                          unknowns,
  double                                       Qin[],
  double                                       Qout[]
) {
  static tarch::logging::Log _log( "exahype2::fv::gpu" );
  logTraceInWith6Arguments( "applyRusanovToPatch_FaceLoops(...)", patchCentre, patchSize, t, dt, numberOfVolumesPerAxisInPatch, unknowns );

  // @todo Docu: Pointer muessen explizit rumkopiert werden -> manual serialisatino
  #if Dimensions==2
  double patchCentreData[] = {patchCentre(0), patchCentre(1)};
  double patchSizeData[]   = {patchSize(0),   patchSize(1)}; 
  #pragma omp target map(to:patchCentreData,patchSizeData,t,dt,numberOfVolumesPerAxisInPatch,unknowns,Qin[0:unknowns*(numberOfVolumesPerAxisInPatch+2)*(numberOfVolumesPerAxisInPatch+2)]) map(from:Qout[0:unknowns*(numberOfVolumesPerAxisInPatch)*(numberOfVolumesPerAxisInPatch)])
  {
    tarch::la::Vector<2,double>  patchCentre(patchCentreData);
    tarch::la::Vector<2,double>  patchSize(patchSizeData);

    double volumeH = ::exahype2::getVolumeLength(patchSize, numberOfVolumesPerAxisInPatch);

    double numericalFluxL[unknowns]; // helper out variable
    double numericalFluxR[unknowns]; // helper out variable

    for (int y=0; y<numberOfVolumesPerAxisInPatch; y++) {
      for (int x=0; x<=numberOfVolumesPerAxisInPatch; x++) {
        const int leftVoxelInPreimage  =  x
                                       + (y+1) * (2 + numberOfVolumesPerAxisInPatch);
        const int rightVoxelInPreimage =  x+1
                                       + (y+1) * (2 + numberOfVolumesPerAxisInPatch);

        const int leftVoxelInImage     = x-1
                                       + y * numberOfVolumesPerAxisInPatch;
        const int rightVoxelInImage    = x
                                       + y * numberOfVolumesPerAxisInPatch;
  
        // This line gives
        //
        // during IPA pass: cp
        // lto1: internal compiler error: Segmentation fault
        //
        // so I have to replace it by a manual construction of the vector 
        // circumnavigating the copy constructor.
        //
        // tarch::la::Vector<Dimensions,double> volumeX = patchCentre - 0.5 * patchSize;

        tarch::la::Vector<Dimensions,double> volumeX;
        volumeX(0) = patchCentre(0) - 0.5 * patchSize(0);
        volumeX(1) = patchCentre(1) - 0.5 * patchSize(1);

        volumeX(0) += x * volumeH;
        volumeX(1) += (y+0.5) * volumeH;

        internal::splitRusanov1d(
          flux, nonconservativeProduct, eigenvalues,
          Qin + leftVoxelInPreimage*unknowns,   // QL
          Qin + rightVoxelInPreimage*unknowns,  // QR
          volumeX, volumeH, t, dt, 0, //  last argument = normal
          unknowns,
          numericalFluxL, numericalFluxR
        );

        for (int unknown=0; unknown<unknowns; unknown++) {
          if (x>0) {
            Qout[ leftVoxelInImage*unknowns+unknown ] -= dt / volumeH * numericalFluxL[unknown];
          }
          if (x<numberOfVolumesPerAxisInPatch) {
            Qout[ rightVoxelInImage*unknowns+unknown ] += dt / volumeH * numericalFluxR[unknown];
          }
        }
      }
    }

    for (int y=0; y<=numberOfVolumesPerAxisInPatch; y++) {
      for (int x=0; x<numberOfVolumesPerAxisInPatch; x++) {
        const int lowerVoxelInPreimage =  x+1
                                       +  y * (2 + numberOfVolumesPerAxisInPatch);
        const int upperVoxelInPreimage =  x+1
                                       + (y+1) * (2 + numberOfVolumesPerAxisInPatch);
   
        const int lowerVoxelInImage    = x
                                       + (y-1) * numberOfVolumesPerAxisInPatch;
        const int upperVoxelInImage    = x
                                       + y * numberOfVolumesPerAxisInPatch;

        tarch::la::Vector<Dimensions,double> volumeX; 
        volumeX(0) = patchCentre(0) - 0.5 * patchSize(0);
        volumeX(1) = patchCentre(1) - 0.5 * patchSize(1);

        volumeX(0) += (x+0.5) * volumeH;
        volumeX(1) += y * volumeH;
 
        internal::splitRusanov1d(
          flux, nonconservativeProduct, eigenvalues,
          Qin + lowerVoxelInPreimage*unknowns,
          Qin + upperVoxelInPreimage*unknowns,
          volumeX, volumeH, t, dt, 1, //  last argument = normala
          unknowns,
          numericalFluxL, numericalFluxR
        );
  
        for (int unknown=0; unknown<unknowns; unknown++) {
          if (y>0) {
            Qout[ lowerVoxelInImage*unknowns+unknown ] -= dt / volumeH * numericalFluxL[unknown];
          }
          if (y<numberOfVolumesPerAxisInPatch) {
            Qout[ upperVoxelInImage*unknowns+unknown ] += dt / volumeH * numericalFluxR[unknown];
          }
        }
      }
    }
  }
  #else
  applySplit1DRiemannToPatch_Overlap1AoS3d(
    [&](
      double                                       QL[],
      double                                       QR[],
      const tarch::la::Vector<Dimensions,double>&  x,
      double                                       dx,
      double                                       t,
      double                                       dt,
      int                                          normal,
      double                                       FL[],
      double                                       FR[]
    ) -> void {
      internal::splitRusanov1d(
        flux, nonconservativeProduct, eigenvalues,
		QL, QR, x, dx, t, dt, normal, unknowns, FL, FR
     );
    },
	patchCentre,
	patchSize,
	t,
	dt,
	numberOfVolumesPerAxisInPatch,
	unknowns,
	Qin,
	Qout
  );
  #endif

  logTraceOutWith6Arguments( "applyRusanovToPatch_FaceLoops(...)", patchCentre, patchSize, t, dt, numberOfVolumesPerAxisInPatch, unknowns );
}
