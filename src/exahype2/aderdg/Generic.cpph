#include "KernelUtils.h"

template< 
  bool useViscousFlux
>
void exahyp2::aderdg::spaceTimePredictor_timeLoop_computeFlux_GaussLegendre_AoS2d(
  std::function< void(
    double * __restrict__                        Q,
    const tarch::la::Vector<Dimensions,double>&  x,
    double                                       t,
    double * __restrict__                        F
  ) >   flux,
  std::function< void(
    double * __restrict__                        Q,
    const tarch::la::Vector<Dimensions,double>&  x,
    double                                       t,
    double * __restrict__                        S
  ) >   source,
  std::function< void(
    double * __restrict__                        Q,
    double                                       gradQ[][Dimensions],
    const tarch::la::Vector<Dimensions,double>&  x,
    double                                       t,
    double * __restrict__                        F
  ) >  viscousFlux,
  std::function< void(
    double * __restrict__                        Q,
    double                                       gradQ[][Dimensions],
    const tarch::la::Vector<Dimensions,double>&  x,
    double                                       t,
    double * __restrict__                        BgradQ
  ) >   nonconservativeProduct,
  int                         order,
  int                         unknowns,
  int                         auxiliaryVariables,
  const double * __restrict__ nodes,
  const double * __restrict__ weights,
  const double * __restrict__ dudx,
  const double * __restrict__ invDx,
  const double * __restrict__ Qi,
  double * __restrict__       gradQ,
  double * __restrict__       gradQCur
) {
  for (int k = 0; k < basisSize; k++) { // presumably k=y
    for (int l = 0; l < basisSize; l++) { // presumably l=x
      // Call PDE fluxes
      const double* Q = lQi + idx_lQi(k, l, i, 0); // TODO(Sven): unused

      double* F[2]; // TODO(Sven): set but not used
      F[0]      = lFi + idx_lFi(i, k, l, 0, 0);
      F[1]      = lFi + idx_lFi(i, k, l, 1, 0);
      if(useViscousFlux){
          viscousFlux(Q,gradQCur+idx_gradQ(k,l,0,0),F);
      }
      else {
          flux(Q,F);
      }
      // everything related to source now moved down to the NCP
    }
  }
}

void spaceTimePredictor_timeLoop_initialiseRhs_GaussLegendre_AoS2d ( ... args ... ) {
  for (int k = 0; k < basisSize; k++) { // y
    for (int l = 0; l < basisSize; l++) { // x
      const double weight = 
          weights[k] *
          weights[l];
      for (int m = 0; m < unknowns; m++) {
        rhs[idx_rhs(i, k, l, m)] = weight * FCoeff[0][i] * luh[idx_luh(k, l, m)]; //FLCoeff == F0
      }
   }
}

template<
  bool useViscousFlux
>
void exahyp2::aderdg::spaceTimePredictor_timeLoop_computeGradient_GaussLegendre_AoS2d(
  int                         order,
  int                         unknowns,
  int                         auxiliaryVariables,
  const double * __restrict__ nodes,
  const double * __restrict__ weights,
  const double * __restrict__ dudx,
  const double * __restrict__ invDx,
  const double * __restrict__ Qi,
  double * __restrict__       gradQ,
  double * __restrict__       gradQCur
) {
  const/*expr*/ int numberOfData       = unknowns+auxiliaryVariables;
  //const/*expr*/ int order              = Order;
  const/*expr*/ int basisSize          = order+1;
  const/*expr*/ int basisSize2         = basisSize * basisSize;
  const/*expr*/ int sizeGradQ          = Dimensions * unknowns * basisSize2;
  
  std::memset(gradQCur, 0, sizeGradQ * sizeof(double));
  
  // Compute the "derivatives" (contributions of the stiffness matrix)
  // x direction (independent from the y derivatives)
  for (int k = 0; k < basisSize; k++) { // k == y
    // Matrix operation
    for (int l = 0; l < basisSize; l++) { // l == x
      for (int m = 0; m < unknowns; m++) {
        for (int n = 0; n < basisSize; n++) { // n == matmul x
          const auto idx = idx_gradQ(k,l, /*x*/0,m);
          const auto tmp = 1.0 * invDx[0] * lQi[idx_lQi(k,n,i,m)] * dudx[l][n];
          gradQCur[idx] += tmp;
          if (useViscousFlux) { // time integration
            gradQ[idx] += tmp * weights[i];
          }
        }
      }
    }
  }
  
  // y direction (independent from the x derivatives)
  for(int k=0; k<basisSize; k++) {
    // Matrix operation
    for (int l = 0; l < basisSize; l++) { // l == y
      for (int m = 0; m < unknowns; m++) {
        for (int n = 0; n < basisSize; n++) { // n = matmul y
          const auto idx = idx_gradQ(l, k, /*y*/1, m);
          const auto t = 1.0 * invDx[1] * lQi[idx_lQi(n, k, i, m)] * dudx[l][n]; /* l,n: transpose */
          gradQCur[idx] += t;
          if (useViscousFlux) {
            gradQ[idx] += t * weights[i];
          }
        }
      }
    }
  }

  // @todo make m-loop inner-most loop if simd target
  // @todo fuse outer loops
}

template <
  bool useSource,
  bool useFlux,
  bool useViscousFlux,
  bool useNCP>
void exahype2::aderdg::spaceTimePredictor_GaussLegendre_AoS2d(
  std::function< void(
    double * __restrict__                        Q,
    const tarch::la::Vector<Dimensions,double>&  x,
    double                                       t,
    double * __restrict__                        F
  ) >   flux,
  std::function< void(
    double * __restrict__                        Q,
    const tarch::la::Vector<Dimensions,double>&  x,
    double                                       t,
    double * __restrict__                        S
  ) >   source,
  std::function< void(
    double * __restrict__                        Q,
    double                                       gradQ[][Dimensions],
    const tarch::la::Vector<Dimensions,double>&  x,
    double                                       t,
    double * __restrict__                        F
  ) >  viscousFlux,
  std::function< void(
    double * __restrict__                        Q,
    double                                       gradQ[][Dimensions],
    const tarch::la::Vector<Dimensions,double>&  x,
    double                                       t,
    double * __restrict__                        BgradQ
  ) >   nonconservativeProduct,
  const tarch::la::Vector<Dimensions,double>&  cellCentre,
  const tarch::la::Vector<Dimensions,double>&  cellSize,
  double                                       t,
  double                                       dt,
  int                                          order,
  int                                          unknowns,
  int                                          auxiliaryVariables,
  bool                                         useMaxPicardIterations,
  int                                          maxPicardIterations,
  const double * __restrict__                  nodes,
  const double * __restrict__                  weights,
  const double * __restrict__                  dudx,
  const double * __restrict__                  FCoeff,
  const double * __restrict__                  iK1,
  const double * __restrict__                  Kxi,
  double * __restrict__                        Qin,
  double * __restrict__                        Qout
) {

/*
template <
  bool useSource,
  bool useFlux,
  bool useViscousFlux,
  bool useNCP>
int aderPicardLoopNonlinear(SolverType& solver,
                             const double* luh, const double t, const double dt,
                             const tarch::la::Vector<Dimensions, double>& cellCenter,
                             const tarch::la::Vector<Dimensions, double>& invDx,
                             double* lQi, double* rhs,
                             double* lFi, double* gradQ) {
*/
  const/*expr*/ int numberOfData       = unknowns+auxiliaryVariables;
  //const/*expr*/ int order              = Order;
  const/*expr*/ int basisSize          = order+1;
  const/*expr*/ int basisSize2         = basisSize * basisSize;
  const/*expr*/ int sizeGradQ          = Dimensions * unknowns * basisSize2;

  const/*expr*/ bool useMaxPicardIterations = UseMaxPicardIterations;
  const/*expr*/ int  maxPicardIterations    = MaxPicardIterations;
  
  assertion(unknowns>=0);
  assertion(auxiliaryVariables>=0);

  idx3 idx_luh(basisSize, basisSize, numberOfData); // idx_luh(y,x,nVar)
  
  idx4 idx_lQi(basisSize, basisSize, basisSize, numberOfData); // idx_lQi(y,x,t,nVar+nPar)
  
  idx5 idx_lFi(basisSize, basisSize, basisSize, Dimensions + 1,unknowns); // idx_lFi(t, y, x, nDim + 1 for Source, nVar)

  // 1. Trivial initial guess
  for (int j = 0; j < basisSize; j++) { // j == y
    for (int k = 0; k < basisSize; k++) { // k == x
      for (int l = 0; l < basisSize; l++) { // l == t
        // Fortran: lQi(m,:,k,j) = luh(m,k,j)
        std::copy_n (luh + idx_luh(j, k, 0), numberOfData,
                     lQi + idx_lQi(j, k, l, 0));
      }
    }
  }
  
  // 2. Discrete Picard iterations
  const/*expr*/ int MaxIterations = (useMaxPicardIterations) ? maxPicardIterations : 2 * (order + 1);

  // right-hand side
  idx4 idx_rhs(basisSize, basisSize, basisSize, unknowns); // idx_rhs(t,y,x,nVar)
  
  // spatial gradient of q
  idx4 idx_gradQ(basisSize, basisSize, Dimensions, unknowns); // idx_gradQ(y,x,nDim,nVar)

   // If the flux depends on the gradient we need to return the time-averaged
  // gradient in gradQ.
  // The variable gradQCur corresponds to the gradient for the
  // current timestep.
  auto gradQCur = gradQ;  // no need to allocate here.
  if (useViscousFlux) {
    // Allocate new buffer for averaged gradient.
    gradQCur = new double[sizeGradQ];
  }

  int iter = 0;
  for (; iter < MaxIterations; iter++) {
      std::memset(gradQ, 0, sizeGradQ * sizeof(double));
    for (int i = 0; i < basisSize; i++) {  // time DOF
      if (useNCP || useViscousFlux) {
        spaceTimePredictor_timeLoop_computeGradient<useViscousFlux>( ...args... );
      }

      // Compute the fluxes
      if (useFlux) {
         spaceTimePredictor_timeLoop_computeFlux<useViscousFlux> ( ...args... );
      }

      // 2. Compute the contribution of the initial condition uh to the right-hand side (rhs0)
      spaceTimePredictor_timeLoop_initialiseRhs_GaussLegendre_AoS2d ( ... args ... );
      
      for (int k = 0; k < basisSize; k++) { // y
        for (int l = 0; l < basisSize; l++) { // x
          const double weight = 
              weights[k] *
              weights[l];
          for (int m = 0; m < unknowns; m++) {
            rhs[idx_rhs(i, k, l, m)] = weight * FCoeff[0][i] * luh[idx_luh(k, l, m)]; //FLCoeff == F0
          }
        }
      }

      // Compute the "derivatives" (contributions of the stiffness matrix)
      // x direction (independent from the y derivatives)
      for (int k = 0; k < basisSize; k++) { // k == y
        const double weight = weights[i] *
                              weights[k];
        const double updateSize = weight * dt * invDx[0];

        // Matrix operation
        for (int l = 0; l < basisSize; l++) { // l == x
          for (int m = 0; m < unknowns; m++) {
            for (int n = 0; n < basisSize; n++) { // n == matmul x
              if (useFlux) {
                rhs[idx_rhs(i, k, l, m)] -= updateSize * lFi[idx_lFi(i, k, n, 0, m)] *
                                            Kxi[n][l];
              }
            }
          }
        }
      }

      // y direction (independent from the x derivatives)
      for(int k=0; k<basisSize; k++) {
        const double weight = weights[i] *
            weights[k];
        const double updateSize = weight * dt * invDx[1];

        // Matrix operation
        for (int l = 0; l < basisSize; l++) { // l == y
          for (int m = 0; m < unknowns; m++) {
            for (int n = 0; n < basisSize; n++) { // n = matmul y
              if (useFlux) {
                rhs[idx_rhs(i, l, k, m)] -= updateSize * lFi[idx_lFi(i, n, k, 1, m)] *
                    Kxi[n][l];
              }
            }
          }
        }
      }

      if(useSource || useNCP) {
        // source
        for (int k=0; k<basisSize; k++) {
          for (int l = 0; l < basisSize; l++) { // l == x
            const double weight = weights[i] *
                weights[k] *
                weights[l];
            const double updateSize = weight * dt;
            double* S = lFi + idx_lFi(i, k, l, 2, 0);

            // by intention, gradQ is undefined if useNCP is wrong. This is because
	        // algebraicSource is only a function of Q and S.
            // Old code (for reference): fusedSource(&lQi[idx_lQi(k, l, i, 0)], &gradQ[idx_gradQ(k, l, i, 0, 0)], S);
            if(useSource) {
              const double ti = t + nodes[i] * dt;
              const double x = cellCenter[0] + (1./invDx[0]) * (nodes[l] - 0.5);
              const double y = cellCenter[1] + (1./invDx[1]) * (nodes[k] - 0.5);
              tarch::la::Vector<Dimensions, double> coords = {x, y};
              algebraicSource(coords, ti, lQi+idx_lQi(k, l, i, 0), S);
            } else {
              std::fill_n(S, unknowns, 0.0);
            }
            if(useNCP) {
              double ncp[unknowns];
              nonConservativeProduct(lQi+idx_lQi(k, l, i, 0), gradQCur+idx_gradQ(k, l, 0, 0), ncp);
              for(int l=0; l<unknowns; l++) {
                S[l] -= ncp[l];
              }
            }

            for (int m = 0; m < unknowns; m++) {
              rhs[idx_rhs(i, k, l, m)] += updateSize * S[m];
            }
          }
        }
      }
    }  // end time dof

    // 3. Multiply with (K1)^(-1) to get the discrete time integral of the
    // discrete Picard iteration
    double sq_res = 0.0;
    for (int j = 0; j < basisSize; j++) { // j == y
      for (int k = 0; k < basisSize; k++) { // k == x
        const double weight = weights[j] *
            weights[k];
        const double iweight = 1.0 / weight;

        // Matrix operation
        for (int l = 0; l < basisSize; l++) { // lQi time
          for (int m = 0; m < unknowns; m++) {
            double lQi_new = 0;
            for (int n = 0; n < basisSize; n++) { // matmul time
              lQi_new += iweight * rhs[idx_rhs(n, j, k, m)] *
                  iK1[l][n]; // note: iK1 is already the transposed inverse of K1
            }
            sq_res += (lQi_new - lQi[idx_lQi(j, k, l, m)]) * (lQi_new - lQi[idx_lQi(j, k, l, m)]);
            assertion3( !std::isnan(lQi[idx_lQi(j, k, l, m)]), idx_lQi(j, k, l, m), dt, invDx );
            assertion3( !std::isnan(lQi_new), idx_lQi(j, k, l, m), dt, invDx );
            lQi[idx_lQi(j, k, l, m)] = lQi_new;
          }
        }
      }
    }

    // Qt is fundamental for debugging, do not remove this.
    /*
    double lQt[basisSize * unknowns];
    idx2 idx_lQt(basisSize, unknowns);
    for (int j = 0; j < basisSize; j++) {
      for (int k = 0; k < basisSize; k++) {
        const double weight = weights[j] *
                              weights[k];
        const double iweight = 1.0 / weight;

        std::memset(lQt, 0, basisSize * unknowns * sizeof(double));
        for (int l = 0; l < basisSize; l++) {
          for (int m = 0; m < unknowns; m++) {
            for (int n = 0; n < basisSize; n++) { // t == n
              lQt[idx_lQt(l, m)] += 1./dt * lQi[idx_lQi(j, k, n, m)] *
                                          dudx[l][n];
            }
            printf("Qt[%d,%d] = %f\n", l, m, lQt[idx_lQt(l,m)]);
          }
        }
      }
    }
     */

    // 4. Exit condition
    if (!useMaxPicardIterations) {
      constexpr double tol = 1e-7;
      if (sq_res < tol * tol) {
        iter = MaxIterations + 1; // break
      }
      
      if (iter == MaxIterations) {  // No convergence after last iteration
        static tarch::logging::Log _log("kernels::aderdg::generic::c");
        logWarning("aderPicardLoopNonlinear(...)",
            "|res|^2=" << sq_res << " > |tol|^2=" << tol * tol << " after "
            << iter << " iterations. Solver seems not to have "
            "converged properly within maximum "
            "number of iteration steps");
      }
    }
  }  // end iter

  // Cleanup iff we use gradient flux
  // In other cases, the pointer gradQCur is owned by the caller.
  if (useViscousFlux) {
    delete gradQCur;
  }
  return iter;
}

