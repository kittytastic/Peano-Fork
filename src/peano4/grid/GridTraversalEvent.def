Packed-Type: long int hint-size 64;
// have to know whether we are using MPI
#include "config.h"
#include "peano4/utils/Globals.h"


Constant: Dimensions  hint-value 4;
Constant: TwoPowerD   hint-value 16;
Constant: TwoTimesD   hint-value 6;
Constant: TwoPowerDTimesTwoPowerD;
Constant: TwoTimesDTimesTwo;
Constant: TwoPowerDTimesTwoPowerDMinusOne;


class peano4::grid::GridTraversalEvent {
  /**
   * Centre of corresponding cell.
   */
  persistent parallelise double         x[Dimensions];
  
  /**
   * Size of corresponding cell.
   */
  persistent parallelise double         h[Dimensions];
  
  /**
   * We use or-based refining.
   */ 
  persistent parallelise packed bool    isRefined[TwoPowerD];
  
  /**
   * Per vertex, we specify from which stack the vertex comes from and in which
   * order the entries are put on the call stack. For the write process when we 
   * leave a cell, it is the other way round. Therefore, we need two entries 
   * per vertex and 2^d entries in total. Only for the cell, we don't need two
   * entries as there's only one cell entry per read/write process.
   *
   * Well too pessimistic upper bound.
   */
  persistent parallelise packed int     vertexDataFrom[TwoPowerD]  from -4 to 9;
  persistent parallelise packed int     vertexDataTo[TwoPowerD]    from -4 to 9;

  persistent parallelise packed int     faceDataFrom[TwoTimesD]    from -4 to 7;
  persistent parallelise packed int     faceDataTo[TwoTimesD]      from -4 to 7;

  persistent parallelise packed int     cellData                   from -4 to 1;

  /**
   * Integer array with entries from 0 to 2.
   */
  persistent parallelise int     relativePositionToFather[Dimensions];

  /**
   * Boundary data exchange. This flag holds per vertex to which other ranks
   * data has to be sent. So the cardinalty has to be @f$ 2^d \cdot (2^d-1) @f$.
   */
  persistent parallelise int     exchangeVertexData[TwoPowerDTimesTwoPowerDMinusOne];
  persistent parallelise int     exchangeFaceData[TwoPowerD];
};

