#include "Node.h"
#include "tarch/mpi/IntegerMessage.h"


template <class Container>
void peano4::parallel::SpacetreeSet::DataExchangeTask::exchangeAllVerticalDataExchangeStacks(
  Container& stackContainer,
  int spacetreeId, int parentId, const std::set<int>& childrenIds,
  VerticalDataExchangeMode mode
) {
  switch (mode) {
    case VerticalDataExchangeMode::Running:
      break;
    case VerticalDataExchangeMode::PrepareDryRunForNewSpacetree:
      {
        const int sourceRank      = Node::getInstance().getRank( parentId );
        assertion( Node::getInstance().getRank( spacetreeId ) == tarch::mpi::Rank::getInstance().getRank() );

        if (sourceRank==tarch::mpi::Rank::getInstance().getRank()) {
          const int sourceStack      = peano4::parallel::Node::getOutputStackNumberForVerticalDataExchange(spacetreeId);
          const int destinationStack = peano4::parallel::Node::getInputStackNumberForVerticalDataExchange(parentId);
          assertion( stackContainer[ peano4::grid::Spacetree::StackKey(spacetreeId,destinationStack) ].empty() );
          logDebug(
            "exchangeAllVerticalDataExchangeStacks(...)",
            "move stack " << sourceStack << " from tree " << spacetreeId << " into stack " << destinationStack << " from tree " << parentId <<
            ": " << stackContainer[ peano4::grid::Spacetree::StackKey(parentId,sourceStack) ].toString()
          );
          stackContainer[ peano4::grid::Spacetree::StackKey(spacetreeId,destinationStack) ].clone( stackContainer[ peano4::grid::Spacetree::StackKey(parentId,sourceStack) ] );
          stackContainer[ peano4::grid::Spacetree::StackKey(spacetreeId,destinationStack) ].reverse();
          stackContainer[ peano4::grid::Spacetree::StackKey(parentId,sourceStack) ].clear();
        }
        else {
          assertionMsg( false, "not yet implemented" );
        }
      }
      break;
    case VerticalDataExchangeMode::ReceiveJoinDataForRunOfMaster:
      for (auto& childId: childrenIds) {
        const int sourceRank      = Node::getInstance().getRank( childId );
        assertion( Node::getInstance().getRank( spacetreeId ) == tarch::mpi::Rank::getInstance().getRank() );

        if (sourceRank==tarch::mpi::Rank::getInstance().getRank()) {
          const int sourceStack      = peano4::parallel::Node::getOutputStackNumberForVerticalDataExchange(spacetreeId);
          const int destinationStack = peano4::parallel::Node::getInputStackNumberForVerticalDataExchange(childId);

          // @todo Debug
          logInfo(
            "exchangeAllVerticalDataExchangeStacks(...)",
            "move stack " << sourceStack << " from tree " << childId << " into stack " << destinationStack << " from tree " << spacetreeId
            << ": transfer " << stackContainer[ peano4::grid::Spacetree::StackKey(childId,sourceStack) ].size() << " element(s)"
          );

          assertion( stackContainer[ peano4::grid::Spacetree::StackKey(spacetreeId,destinationStack) ].empty() );
          stackContainer[ peano4::grid::Spacetree::StackKey(spacetreeId,destinationStack) ].clone( stackContainer[ peano4::grid::Spacetree::StackKey(childId,sourceStack) ] );
          stackContainer[ peano4::grid::Spacetree::StackKey(spacetreeId,destinationStack) ].reverse();
          stackContainer[ peano4::grid::Spacetree::StackKey(childId,sourceStack) ].clear();
        }
        else {
          assertionMsg( false, "not yet implemented" );
        }
      }
      break;
  }

  // Send out stuff via MPI
/*
  for (auto sourceStack = stackContainer.begin(); sourceStack != stackContainer.end(); ) {
    if (
      sourceStack->first.first==spacetreeId
      and
      Node::getInstance().isVerticalDataExchangeOutputStackNumber(sourceStack->first.second)
      and
      not sourceStack->second.empty()
      and
      Node::getInstance().getRank( Node::getInstance().getIdOfExchangeStackNumber(sourceStack->first.second) )!=tarch::mpi::Rank::getInstance().getRank()
    ) {
      assertionMsg( false, "sends not yet implemented" );
      // evtl. muss ich hier brutal aufpassen, dass ich sofort wieder ein clear aufrufe
    }
  }

  for (auto& sourceStack: stackContainer.begin(); sourceStack != stackContainer.end(); ) {
    if (
      sourceStack->first.first==spacetreeId
      and
      Node::getInstance().isVerticalDataExchangeInputStackNumber(sourceStack->first.second)
//      and
//      Node::getInstance().getOutputStackNumberForVerticalDataExchange()IdOfExchangeStackNumber() == parentId
      and
      (
        mode == VerticalDataExchangeMode::Running
      )
    ) {
      if ( Node::getInstance().getRank( parentId )==tarch::mpi::Rank::getInstance().getRank() ) {
      }
      else {
        assertionMsg( false, "do not support ranks yet that reside on a different MPI rank" );
      }
    }
  }
*/



/*
  const int destinationRank = Node::getInstance().getRank( destinationSpacetreeId );
  const int sourceRank      = Node::getInstance().getRank( sourceSpacetreeId );
  if (
    destinationRank != tarch::mpi::Rank::getInstance().getRank()
    and
    sourceRank      == tarch::mpi::Rank::getInstance().getRank()
  ) {
    const int tag = Node::getInstance().getGridDataExchangeTag( sourceSpacetreeId, destinationSpacetreeId, Node::ExchangeMode::SendVerticalData );
    logInfo(
      "exchangeStacksSynchronously(...)",
      "send stack " << sourceStack << " from tree " << sourceSpacetreeId << " to rank " << destinationRank <<
      ": " << stackContainer[ peano4::grid::Spacetree::StackKey(destinationSpacetreeId,destinationStack) ].toString()
    );

    tarch::mpi::IntegerMessage message( stackContainer[ peano4::grid::Spacetree::StackKey(sourceSpacetreeId,sourceStack) ].size() );
    message.send(destinationRank,tag,false,tarch::mpi::IntegerMessage::ExchangeMode::NonblockingWithPollingLoopOverTests);

    stackContainer[ peano4::grid::Spacetree::StackKey(sourceSpacetreeId,sourceStack) ].startSend(destinationRank,tag);
    stackContainer[ peano4::grid::Spacetree::StackKey(sourceSpacetreeId,sourceStack) ].finishSendOrReceive();
  }
  else if (
    destinationRank == tarch::mpi::Rank::getInstance().getRank()
    and
    sourceRank      != tarch::mpi::Rank::getInstance().getRank()
  ) {
    const int tag = Node::getInstance().getGridDataExchangeTag( sourceSpacetreeId, destinationSpacetreeId, Node::ExchangeMode::ReceiveVerticalData );
    logInfo(
      "exchangeStacksSynchronously(...)",
      "receive stack " << destinationStack << " of tree " << destinationSpacetreeId << " from tree " << sourceSpacetreeId << " on rank " << sourceRank
    );
    assertion( stackContainer[ peano4::grid::Spacetree::StackKey(destinationSpacetreeId,destinationStack) ].empty() );

    tarch::mpi::IntegerMessage message;
    message.receive(sourceRank,tag,false,tarch::mpi::IntegerMessage::ExchangeMode::NonblockingWithPollingLoopOverTests);

    stackContainer[ peano4::grid::Spacetree::StackKey(destinationSpacetreeId,destinationStack) ].startReceive(sourceRank,tag,message.getValue());
    stackContainer[ peano4::grid::Spacetree::StackKey(destinationSpacetreeId,destinationStack) ].finishSendOrReceive();
  }
*/
}


template <class Container>
void peano4::parallel::SpacetreeSet::DataExchangeTask::exchangeAllHorizontalDataExchangeStacks( Container& stackContainer, int spacetreeId, bool symmetricDataCardinality ) {
  assertionMsg( symmetricDataCardinality, "haven't implemented the asymetric case yet, but would be simple: Just need the integer messages as I do for the vertical data flow" );
  // Trigger all send and receives required
  // --------------------------------------
  // We exploit all the symmetries
  for (auto& sourceStack: stackContainer) {
    if (
      sourceStack.first.first==spacetreeId
      and
      Node::getInstance().isHorizontalDataExchangeOutputStackNumber(sourceStack.first.second)
      and
      not sourceStack.second.empty()
      and
      Node::getInstance().getRank( Node::getInstance().getIdOfExchangeStackNumber(sourceStack.first.second) )!=tarch::mpi::Rank::getInstance().getRank()
    ) {
      int targetId  = Node::getInstance().getIdOfExchangeStackNumber(sourceStack.first.second);
      int rank      = Node::getInstance().getRank( targetId );
      int count     = sourceStack.second.size();
      int inStack   = Node::getInstance().getInputStackNumberOfHorizontalDataExchange(targetId);

      int tag       = Node::getInstance().getGridDataExchangeTag( spacetreeId, targetId, Node::ExchangeMode::SendHorizontalData );
      logInfo( "exchangeStacksAsynchronously(...)", "send stack " << sourceStack.first.second << " of tree " << sourceStack.first.first << " to rank " << rank << " with tag " << tag );
      sourceStack.second.startSend(rank,tag);

      tag           = Node::getInstance().getGridDataExchangeTag( targetId, spacetreeId, Node::ExchangeMode::ReceiveHorizontalData );
      logInfo( "exchangeStacksAsynchronously(...)", "in return, receive " << count << " element(s) from rank " << rank << " with tag " << tag << " into stack " << inStack );
      assertion(not Node::getInstance().isHorizontalDataExchangeOutputStackNumber(inStack));
      stackContainer[ peano4::grid::Spacetree::StackKey(spacetreeId,inStack) ].startReceive(rank,tag,count);
    }
  }

  // All local boundary stacks
  // -------------------------
  for (auto sourceStack = stackContainer.begin(); sourceStack != stackContainer.end(); ) {
    if (
      sourceStack->first.first==spacetreeId
      and
      Node::getInstance().isHorizontalDataExchangeOutputStackNumber(sourceStack->first.second)
      and
      not sourceStack->second.empty()
      and
      Node::getInstance().getRank( Node::getInstance().getIdOfExchangeStackNumber(sourceStack->first.second) )==tarch::mpi::Rank::getInstance().getRank()
    ) {
      const int targetId = Node::getInstance().getIdOfExchangeStackNumber(sourceStack->first.second);

      const int targetStack = Node::getInstance().getInputStackNumberOfHorizontalDataExchange(spacetreeId);
      logDebug(
         "exchangeStacksAsynchronously(...)",
         "map output stream " << sourceStack->first.second << " of tree " <<
         spacetreeId << " onto input stream " << targetStack <<
         " of tree " << targetId <<
         ". Copy/clone " << stackContainer[ peano4::grid::Spacetree::StackKey( sourceStack->first.first,sourceStack->first.second) ].size() << " entries"
      );

      assertion3(
        stackContainer[ peano4::grid::Spacetree::StackKey(targetId,targetStack) ].empty(),
        targetId,targetStack,spacetreeId
      );
      stackContainer[ peano4::grid::Spacetree::StackKey(targetId,targetStack) ].clone( sourceStack->second );

      #if PeanoDebug>0
      const int comparisonStackForTarget = Node::getInstance().getOutputStackNumberOfHorizontalDataExchange( spacetreeId );

      assertion8(
        stackContainer[ peano4::grid::Spacetree::StackKey(targetId,targetStack) ].size() == stackContainer[ peano4::grid::Spacetree::StackKey(spacetreeId,comparisonStackForTarget) ].size()
        or
        stackContainer[ peano4::grid::Spacetree::StackKey(spacetreeId,comparisonStackForTarget) ].empty(),
        stackContainer[ peano4::grid::Spacetree::StackKey(targetId,targetStack) ].size(),
        stackContainer[ peano4::grid::Spacetree::StackKey(spacetreeId,comparisonStackForTarget) ].size(),
        stackContainer[ peano4::grid::Spacetree::StackKey(targetId,targetStack) ].toString(),
        stackContainer[ peano4::grid::Spacetree::StackKey(spacetreeId,comparisonStackForTarget) ].toString(),
        targetStack, comparisonStackForTarget, spacetreeId,
        "target stack is what I have already sent over"
      );
      #endif

      stackContainer[sourceStack->first].clear();

      sourceStack++;
    }
    else if (
      Node::getInstance().isHorizontalDataExchangeOutputStackNumber( sourceStack->first.second )
      and
      sourceStack->second.empty()
    ) {
      sourceStack = stackContainer.erase(sourceStack);
    }
    else {
      sourceStack++;
    }
  }
}


template <class Container>
void peano4::parallel::SpacetreeSet::DataExchangeTask::finishAllOutstandingSendsAndReceives( Container& stackContainer, int spacetreeId ) {
  // Finalise data exchange
  // ----------------------
  for (auto& sourceStack: stackContainer) {
    if (
      sourceStack.first.first==spacetreeId
      and
      sourceStack.second.isSendingOrReceiving()
    ) {
      sourceStack.second.finishSendOrReceive();
    }
  }
}


template <class Container>
void peano4::parallel::SpacetreeSet::DataExchangeTask::exchangeAllPeriodicBoundaryDataStacks( Container& stackContainer, int spacetreeId ) {
  for (auto& sourceStack: stackContainer ) {
    if (
      sourceStack.first.first==spacetreeId
      and
      Node::getInstance().isPeriodicBoundaryExchangeOutputStackNumber(sourceStack.first.second)
      and
      not sourceStack.second.empty()
    ) {
      const int targetStack = Node::getInstance().getPeriodicBoundaryExchangeInputStackNumberForOutputStack(sourceStack.first.second);
      logDebug(
         "exchangeStacksAsynchronously(...)",
         "map output stream " << sourceStack.first.second << " onto input stream " << targetStack <<
         " to realise periodic boundary conditions. Copy/clone " << stackContainer[ peano4::grid::Spacetree::StackKey( sourceStack.first.first,sourceStack.first.second) ].size() << " entries"
      );
      logDebug(
         "exchangeStacksAsynchronously(...)",
         stackContainer[ peano4::grid::Spacetree::StackKey( sourceStack.first.first,sourceStack.first.second) ].toString()
      );

      assertion3(
        stackContainer[ peano4::grid::Spacetree::StackKey(sourceStack.first.first,targetStack) ].empty(),
        sourceStack.first.first,sourceStack.first.second,targetStack
      );
      stackContainer[ peano4::grid::Spacetree::StackKey(sourceStack.first.first,targetStack) ].clone( sourceStack.second );
      stackContainer[sourceStack.first].clear();
    }
  }
}

