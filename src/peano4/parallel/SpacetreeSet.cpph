#include "Node.h"
#include "tarch/mpi/IntegerMessage.h"
#include "peano4/grid/PeanoCurve.h"


template <class Container>
void peano4::parallel::SpacetreeSet::exchangeAllVerticalDataExchangeStacks(
  Container& stackContainer,
  int spacetreeId, int parentId,
  const std::set<int>& joiningIds
) {
  logTraceInWith2Arguments( "exchangeAllVerticalDataExchangeStacks(...)", spacetreeId, parentId );


  // @todo receive von remote data fehlt
  /*
  else if (
    destinationRank == tarch::mpi::Rank::getInstance().getRank()
    and
    sourceRank      != tarch::mpi::Rank::getInstance().getRank()
  ) {
    const int tag = Node::getInstance().getGridDataExchangeTag( sourceSpacetreeId, destinationSpacetreeId, Node::ExchangeMode::ReceiveVerticalData );
    logInfo(
      "exchangeStacksSynchronously(...)",
      "receive stack " << destinationStack << " of tree " << destinationSpacetreeId << " from tree " << sourceSpacetreeId << " on rank " << sourceRank
    );
    assertion( stackContainer[ peano4::grid::Spacetree::StackKey(destinationSpacetreeId,destinationStack) ].empty() );

    tarch::mpi::IntegerMessage message;
    message.receive(sourceRank,tag,false,tarch::mpi::IntegerMessage::ExchangeMode::NonblockingWithPollingLoopOverTests);

    stackContainer[ peano4::grid::Spacetree::StackKey(destinationSpacetreeId,destinationStack) ].startReceive(sourceRank,tag,message.getValue());
    stackContainer[ peano4::grid::Spacetree::StackKey(destinationSpacetreeId,destinationStack) ].finishSendOrReceive();
  }
*/
  logTraceOutWith2Arguments( "exchangeAllVerticalDataExchangeStacks(...)", spacetreeId, parentId );
}


template <class Container>
void peano4::parallel::SpacetreeSet::exchangeAllHorizontalDataExchangeStacks( Container& stackContainer, int spacetreeId, bool symmetricDataCardinality ) {
  logTraceInWith2Arguments( "exchangeAllHorizontalDataExchangeStacks(...)", spacetreeId, symmetricDataCardinality );
  assertionMsg( symmetricDataCardinality, "haven't implemented the asymetric case yet, but would be simple: Just need the integer messages as I do for the vertical data flow" );
  // Trigger all send and receives required
  // --------------------------------------
  // We exploit all the symmetries
  std::set< peano4::maps::StackKey > keys = stackContainer.getKeys();
  for (auto& sourceStackKey: keys) {
    if (
      sourceStackKey.first==spacetreeId
      and
      Node::getInstance().isHorizontalDataExchangeOutputStackNumber(sourceStackKey.second)
      and
      not stackContainer.getForPush(sourceStackKey)->empty()
      and
      Node::getInstance().getRank( Node::getInstance().getTreeNumberTiedToExchangeStackNumber(sourceStackKey.second) )!=tarch::mpi::Rank::getInstance().getRank()
    ) {
      int targetId  = Node::getInstance().getTreeNumberTiedToExchangeStackNumber(sourceStackKey.second);
      int rank      = Node::getInstance().getRank( targetId );
      int count     = stackContainer.getForPush(sourceStackKey)->size();
      int inStack   = Node::getInstance().getInputStackNumberForHorizontalDataExchange(targetId);

      int sendTag       = Node::getInstance().getGridDataExchangeTag( spacetreeId, targetId, Node::ExchangeMode::HorizontalData );
      logDebug( "exchangeAllHorizontalDataExchangeStacks(...)", "send stack " << sourceStackKey.second << " of tree " << sourceStackKey.first << " to rank " << rank << " with tag " << sendTag << ": " << count << " element(s)");
      stackContainer.getForPush(sourceStackKey)->startSend(rank,sendTag);

      int receiveTag    = Node::getInstance().getGridDataExchangeTag( targetId, spacetreeId, Node::ExchangeMode::HorizontalData );
      logDebug( "exchangeAllHorizontalDataExchangeStacks(...)", "in return, receive " << count << " element(s) from rank " << rank << " with tag " << receiveTag << " into stack " << inStack );
      assertion(not Node::getInstance().isHorizontalDataExchangeOutputStackNumber(inStack));
      stackContainer.getForPush(spacetreeId,inStack)->startReceive(rank,receiveTag,count);
    }
  }

  // All local boundary stacks
  // -------------------------
  for (auto sourceStackKey: keys) {
    if (
      sourceStackKey.first==spacetreeId
      and
      Node::getInstance().isHorizontalDataExchangeOutputStackNumber(sourceStackKey.second)
      and
      not stackContainer.getForPush(sourceStackKey)->empty()
      and
      Node::getInstance().getRank( Node::getInstance().getTreeNumberTiedToExchangeStackNumber(sourceStackKey.second) )==tarch::mpi::Rank::getInstance().getRank()
    ) {
      const int targetId = Node::getInstance().getTreeNumberTiedToExchangeStackNumber(sourceStackKey.second);

      const int targetStack = Node::getInstance().getInputStackNumberForHorizontalDataExchange(spacetreeId);
      logDebug(
         "exchangeAllHorizontalDataExchangeStacks(...)",
         "map output stream " << sourceStackKey.second << " of tree " <<
         spacetreeId << " onto input stream " << targetStack <<
         " of tree " << targetId <<
         ". Copy " << stackContainer.getForPush(sourceStackKey)->size() << " entries"
      );

      stackContainer.getForPush(targetId,targetStack)->clone( *stackContainer.getForPop(sourceStackKey) );

      #if PeanoDebug>0
      const int comparisonStackForTarget = Node::getInstance().getOutputStackNumberForHorizontalDataExchange( spacetreeId );

      assertion8(
        stackContainer.getForPush(targetId,targetStack)->size() == stackContainer.getForPush(spacetreeId,comparisonStackForTarget)->size()
        or
        stackContainer.getForPush(spacetreeId,comparisonStackForTarget)->empty(),
        stackContainer.getForPush(targetId,targetStack)->size(),
        stackContainer.getForPush(spacetreeId,comparisonStackForTarget)->size(),
        stackContainer.getForPush(targetId,targetStack)->toString(),
        stackContainer.getForPush(spacetreeId,comparisonStackForTarget)->toString(),
        targetStack, comparisonStackForTarget, spacetreeId,
        "target stack is what I have already sent over"
      );
      #endif

      stackContainer.getForPush(sourceStackKey)->clear();
    }
  }
  logTraceOut( "exchangeAllHorizontalDataExchangeStacks(...)" );
}


template <class Container>
void peano4::parallel::SpacetreeSet::finishAllOutstandingSendsAndReceives( Container& stackContainer, int spacetreeId ) {
  // Finalise data exchange
  // ----------------------
  std::set< peano4::maps::StackKey > keys = stackContainer.getKeys();
  for (auto& sourceStackKey: keys) {
    if ( sourceStackKey.first==spacetreeId ) {
      stackContainer.getForPush(sourceStackKey)->finishSendOrReceive();
    }
  }

  stackContainer.garbageCollection();
}


template <class Container>
void peano4::parallel::SpacetreeSet::exchangeAllPeriodicBoundaryDataStacks( Container& stackContainer, int spacetreeId ) {
  std::set< peano4::maps::StackKey > keys = stackContainer.getKeys();
  for (auto& sourceStackKey: keys) {
    if (
      sourceStackKey.first==spacetreeId
      and
      Node::getInstance().isPeriodicBoundaryExchangeOutputStackNumber(sourceStackKey.second)
      and
      not stackContainer.getForPush(sourceStackKey)->empty()
    ) {
      const int targetStack = Node::getInstance().getPeriodicBoundaryExchangeInputStackNumberForOutputStack(sourceStackKey.second);
      logDebug(
         "exchangeStacksAsynchronously(...)",
         "map output stream " << sourceStackKey.second << " onto input stream " << targetStack <<
         " to realise periodic boundary conditions. Copy/clone " << stackContainer.getForPush(sourceStackKey)->size() << " entries"
      );
      logDebug(
         "exchangeStacksAsynchronously(...)",
         stackContainer.getForPush(sourceStackKey)->toString()
      );

      stackContainer.getForPush(sourceStackKey.first,targetStack)->clone( *stackContainer.getForPush(sourceStackKey) );
      stackContainer.getForPush(sourceStackKey)->clear();
    }
  }
}

