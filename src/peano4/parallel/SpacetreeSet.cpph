#include "Node.h"


template <class Container>
void peano4::parallel::SpacetreeSet::DataExchangeTask::exchangeStacksSynchronously( Container& stackContainer, int sourceSpacetreeId, int destinationSpacetreeId ) {
  const int sourceStack      = peano4::parallel::Node::getOutputStackNumberForSplitMergeDataExchange(destinationSpacetreeId);
  const int destinationStack = peano4::parallel::Node::getInputStackNumberForSplitMergeDataExchange(sourceSpacetreeId);

  assertion( peano4::grid::Spacetree::_vertexStack[ peano4::grid::Spacetree::StackKey(destinationSpacetreeId,destinationStack) ].empty() );
  peano4::grid::Spacetree::_vertexStack[ peano4::grid::Spacetree::StackKey(destinationSpacetreeId,destinationStack) ].clone( peano4::grid::Spacetree::_vertexStack[ peano4::grid::Spacetree::StackKey(sourceSpacetreeId,sourceStack) ] );
  peano4::grid::Spacetree::_vertexStack[ peano4::grid::Spacetree::StackKey(destinationSpacetreeId,destinationStack) ].reverse();
  peano4::grid::Spacetree::_vertexStack[ peano4::grid::Spacetree::StackKey(sourceSpacetreeId,sourceStack) ].clear();

  logDebug(
    "exchangeStacksSynchronously(...)",
    "stream stack " << sourceStack << " from tree " << sourceSpacetreeId << " into stack " << destinationStack << " from tree " << destinationSpacetreeId <<
    ": " << peano4::grid::Spacetree::_vertexStack[ peano4::grid::Spacetree::StackKey(destinationSpacetreeId,destinationStack) ].toString()
  );
}


template <class Container>
void peano4::parallel::SpacetreeSet::DataExchangeTask::exchangeStacksAsynchronously( Container& stackContainer, int spacetreeId ) {
  // Trigger all send and receives required
  // --------------------------------------
  // We exploit all the symmetries
  for (auto& sourceStack: stackContainer) {
    if (
      sourceStack.first.first==spacetreeId
      and
      Node::getInstance().isBoundaryExchangeOutputStackNumber(sourceStack.first.second)
      and
      not sourceStack.second.empty()
      and
      Node::getInstance().getRank( Node::getInstance().getIdOfExchangeStackNumber(sourceStack.first.second) )!=tarch::mpi::Rank::getInstance().getRank()
    ) {
      int targetId  = Node::getInstance().getIdOfExchangeStackNumber(sourceStack.first.second);
      int rank      = Node::getInstance().getRank( targetId );
      int count     = sourceStack.second.size();
      int inStack   = Node::getInstance().getInputStackNumberOfBoundaryExchange(targetId);

      int tag       = Node::getInstance().getGridDataExchangeTag( spacetreeId, targetId, true );
      logInfo( "DataExchangeTask::run()", "send stack " << sourceStack.first.second << " of tree " << sourceStack.first.first << " to rank " << rank << " with tag " << tag );
      sourceStack.second.startSend(rank,tag);

      tag           = Node::getInstance().getGridDataExchangeTag( targetId, spacetreeId, true );
      logInfo( "DataExchangeTask::run()", "in return, receive " << count << " element(s) from rank " << rank << " with tag " << tag << " into stack " << inStack );
      assertion(not Node::getInstance().isBoundaryExchangeOutputStackNumber(inStack));
      stackContainer[ peano4::grid::Spacetree::StackKey(spacetreeId,inStack) ].startReceive(rank,tag,count);
    }
  }

  // All local stacks
  // ----------------
  for (auto sourceStack = stackContainer.begin(); sourceStack != stackContainer.end(); ) {
    if (
      sourceStack->first.first==spacetreeId
      and
      Node::getInstance().isBoundaryExchangeOutputStackNumber(sourceStack->first.second)
      and
      not sourceStack->second.empty()
      and
      Node::getInstance().getRank( Node::getInstance().getIdOfExchangeStackNumber(sourceStack->first.second) )==tarch::mpi::Rank::getInstance().getRank()
    ) {
      const int targetId = Node::getInstance().getIdOfExchangeStackNumber(sourceStack->first.second);

      const int targetStack = Node::getInstance().getInputStackNumberOfBoundaryExchange(spacetreeId);
      logDebug(
         "DataExchangeTask::run()",
         "map output stream " << sourceStack->first.second << " of tree " <<
         spacetreeId << " onto input stream " << targetStack <<
         " of tree " << targetId <<
         ". Copy/clone " << stackContainer[ peano4::grid::Spacetree::StackKey( sourceStack->first.first,sourceStack->first.second) ].size() << " entries"
      );

      assertion3( spacetreeId != targetId, spacetreeId, targetId, targetStack);

      peano4::grid::Spacetree::_vertexStack[ peano4::grid::Spacetree::StackKey(targetId,targetStack) ].clone( sourceStack->second );

      #if PeanoDebug>0
      const int comparisonStackForTarget = Node::getInstance().getOutputStackNumberOfBoundaryExchange( spacetreeId );

      assertion8(
        stackContainer[ peano4::grid::Spacetree::StackKey(targetId,targetStack) ].size() == stackContainer[ peano4::grid::Spacetree::StackKey(spacetreeId,comparisonStackForTarget) ].size()
        or
        stackContainer[ peano4::grid::Spacetree::StackKey(spacetreeId,comparisonStackForTarget) ].empty(),
        stackContainer[ peano4::grid::Spacetree::StackKey(targetId,targetStack) ].size(),
        stackContainer[ peano4::grid::Spacetree::StackKey(spacetreeId,comparisonStackForTarget) ].size(),
        stackContainer[ peano4::grid::Spacetree::StackKey(targetId,targetStack) ].toString(),
        stackContainer[ peano4::grid::Spacetree::StackKey(spacetreeId,comparisonStackForTarget) ].toString(),
        targetStack, comparisonStackForTarget, spacetreeId,
        "target stack is what I have already sent over"
      );
      #endif

      stackContainer[sourceStack->first].clear();

      sourceStack++;
    }
    else if (
      Node::getInstance().isBoundaryExchangeOutputStackNumber( sourceStack->first.second )
      and
      sourceStack->second.empty()
    ) {
      sourceStack = stackContainer.erase(sourceStack);
    }
    else {
      sourceStack++;
    }
  }

  // Finalise data exchange
  // ----------------------
  // @todo Das ist jetzt halt wieder net so klasse, weil das logisch ordnet.
  for (auto& sourceStack: stackContainer) {
    if ( sourceStack.second.isSendingOrReceiving() ) {
      sourceStack.second.finishSendOrReceive();
    }
  }
}

