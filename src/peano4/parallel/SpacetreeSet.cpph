#include "Node.h"
#include "tarch/mpi/IntegerMessage.h"
#include "peano4/grid/PeanoCurve.h"




template <class Container>
void peano4::parallel::SpacetreeSet::streamDataFromJoiningTreeToMasterTree(
  Container& stackContainer, int master, int worker
) {

}


template <class Container>
void peano4::parallel::SpacetreeSet::deleteAllStacks(
  Container& stackContainer,
  int spacetreeId
) {
 assertion( Node::getInstance().getRank( spacetreeId ) == tarch::mpi::Rank::getInstance().getRank() );
 std::set< peano4::maps::StackKey > keys = stackContainer.getKeys();
 for (auto& sourceStackKey: keys) {
   if ( sourceStackKey.first==spacetreeId ) {
     stackContainer.getForPush(sourceStackKey)->clear();
   }
 }
}


template <class Container>
void peano4::parallel::SpacetreeSet::streamDataFromSplittingTreeToNewTree(
  Container& stackContainer, int master, int worker
) {
  logTraceInWith2Arguments( "streamDataFromSplittingTreeToNewTree(...)", master, worker );
  const int sourceRank      = Node::getInstance().getRank( master );
  const int destinationRank = Node::getInstance().getRank( worker );

  if (
    sourceRank==tarch::mpi::Rank::getInstance().getRank()
    and
    destinationRank==tarch::mpi::Rank::getInstance().getRank()
  ) {
    int  destinationStack = peano4::grid::PeanoCurve::getOutputStackNumber( getInstance().getSpacetree(worker)._root );
    if ( stackContainer.getForPush(worker,destinationStack)->empty() ) {
      const int sourceStack      = peano4::grid::PeanoCurve::getInputStackNumber( getInstance().getSpacetree(master)._root );
      logDebug(
        "copyDataFromSplittingTreesToNewTrees()",
        "copy stack " << sourceStack << " from tree " << master << " into stack " << destinationStack << " from tree " << worker
      );
      stackContainer.getForPush(worker,destinationStack)->clone( *stackContainer.getForPush(master,sourceStack) );

      logDebug(
        "copyDataFromSplittingTreesToNewTrees()",
        "size of stack " << destinationStack << " on tree " << master << ": " << stackContainer.getForPush(master,destinationStack)->size()
      );
    }
    else {
      logDebug(
        "copyDataFromSplittingTreesToNewTrees()",
        "target stack " << destinationStack << " of tree " << worker << " is already full, so skip copying"
      );
    }
  }
  else if ( sourceRank==tarch::mpi::Rank::getInstance().getRank() ) {
    #ifdef Parallel
    const int tag            = peano4::parallel::Node::getInstance().getGridDataExchangeTag(master, worker, peano4::parallel::Node::ExchangeMode::VerticalData);
    const int sourceStack    = peano4::grid::PeanoCurve::getInputStackNumber( getInstance().getSpacetree(master)._root );
    const int messageSize    = stackContainer.getForPop(master,sourceStack)->size();
    const int temporaryStack = Node::getOutputStackNumberForVerticalDataExchange(worker);

// @todo Debug
    logInfo(
      "copyDataFromSplittingTreesToNewTrees()",
      "send stack " << sourceStack << " from tree " << master << " on rank " << sourceRank << " through tag " << tag <<
      " to tree " << worker << " on rank " << destinationRank << ". size=" << messageSize
    );
    tarch::mpi::IntegerMessage message( messageSize );
    tarch::mpi::IntegerMessage::send(message, destinationRank, tag, tarch::mpi::Rank::getInstance().getCommunicator());

    if (messageSize>0) {
      stackContainer.getForPush(master,temporaryStack)->clone( *stackContainer.getForPop(master,sourceStack) );
      stackContainer.getForPush(master,temporaryStack)->startSend(
        destinationRank, tag
      );
    }
logInfo( "copyDataFromSplittingTreesToNewTrees()", "this receive is triggered. Next one ..." );
    #else
    assertionMsg( false, "should never be entered" );
    #endif
  }
  else if ( destinationRank==tarch::mpi::Rank::getInstance().getRank() ) {
    #ifdef Parallel
    int  destinationStack = peano4::grid::PeanoCurve::getOutputStackNumber( getInstance().getSpacetree(worker)._root );
    const int tag         = peano4::parallel::Node::getInstance().getGridDataExchangeTag(master, worker, peano4::parallel::Node::ExchangeMode::VerticalData);

    tarch::mpi::IntegerMessage message;
    tarch::mpi::IntegerMessage::receiveAndPollDanglingMessages(message, sourceRank, tag);
    logDebug(
      "copyDataFromSplittingTreesToNewTrees()",
      "receive " << message.getValue() << " entries from tree " << master << " on rank " << sourceRank << " (used tag " << tag << ")"
    );
    if (message.getValue()>0) {
      stackContainer.getForPush(worker,destinationStack)->startReceive(
        sourceRank, tag, message.getValue()
      );
    }
    #else
    assertionMsg( false, "should never be entered" );
    #endif
  }
  logTraceOutWith2Arguments( "streamDataFromSplittingTreeToNewTree(...)", master, worker );
}


template <class Container>
void peano4::parallel::SpacetreeSet::exchangeAllVerticalDataExchangeStacks(
  Container& stackContainer,
  int spacetreeId, int parentId
) {
  logTraceInWith2Arguments( "exchangeAllVerticalDataExchangeStacks(...)", spacetreeId, parentId );
  logTraceOutWith2Arguments( "exchangeAllVerticalDataExchangeStacks(...)", spacetreeId, parentId );
}


template <class Container>
void peano4::parallel::SpacetreeSet::exchangeAllHorizontalDataExchangeStacks( Container& stackContainer, int spacetreeId, bool symmetricDataCardinality ) {
  logTraceInWith2Arguments( "exchangeAllHorizontalDataExchangeStacks(...)", spacetreeId, symmetricDataCardinality );
  assertionMsg( symmetricDataCardinality, "haven't implemented the asymetric case yet, but would be simple: Just need the integer messages as I do for the vertical data flow" );
  // Trigger all send and receives required
  // --------------------------------------
  // We exploit all the symmetries
  std::set< peano4::maps::StackKey > keys = stackContainer.getKeys();
  for (auto& sourceStackKey: keys) {
    if (
      sourceStackKey.first==spacetreeId
      and
      Node::getInstance().isHorizontalDataExchangeOutputStackNumber(sourceStackKey.second)
      and
      not stackContainer.getForPush(sourceStackKey)->empty()
      and
      Node::getInstance().getRank( Node::getInstance().getTreeNumberTiedToExchangeStackNumber(sourceStackKey.second) )!=tarch::mpi::Rank::getInstance().getRank()
    ) {
      int targetId       = Node::getInstance().getTreeNumberTiedToExchangeStackNumber(sourceStackKey.second);
      int rank           = Node::getInstance().getRank( targetId );
      int count          = stackContainer.getForPush(sourceStackKey)->size();
      int inStack        = Node::getInstance().getInputStackNumberForHorizontalDataExchange(targetId);

      int sendTag       = Node::getInstance().getGridDataExchangeTag( spacetreeId, targetId, Node::ExchangeMode::HorizontalData );
      logDebug( "exchangeAllHorizontalDataExchangeStacks(...)", "send stack " << sourceStackKey.second << " of tree " << sourceStackKey.first << " to rank " << rank << " with tag " << sendTag << ": " << count << " element(s)");

      stackContainer.getForPush(sourceStackKey)->startSend(rank,sendTag);

      int receiveTag    = Node::getInstance().getGridDataExchangeTag( targetId, spacetreeId, Node::ExchangeMode::HorizontalData );

      logDebug( "exchangeAllHorizontalDataExchangeStacks(...)", "in return, receive " << count << " element(s) from rank " << rank << " with tag " << receiveTag << " into stack " << inStack );
      assertion(not Node::getInstance().isHorizontalDataExchangeOutputStackNumber(inStack));
      stackContainer.getForPush(spacetreeId,inStack)->startReceive(rank,receiveTag,count);
    }
  }

  // All local boundary stacks
  // -------------------------
  for (auto sourceStackKey: keys) {
    if (
      sourceStackKey.first==spacetreeId
      and
      Node::getInstance().isHorizontalDataExchangeOutputStackNumber(sourceStackKey.second)
      and
      not stackContainer.getForPush(sourceStackKey)->empty()
      and
      Node::getInstance().getRank( Node::getInstance().getTreeNumberTiedToExchangeStackNumber(sourceStackKey.second) )==tarch::mpi::Rank::getInstance().getRank()
    ) {
      const int targetId = Node::getInstance().getTreeNumberTiedToExchangeStackNumber(sourceStackKey.second);

      const int targetStack = Node::getInstance().getInputStackNumberForHorizontalDataExchange(spacetreeId);
      logDebug(
         "exchangeAllHorizontalDataExchangeStacks(...)",
         "map output stream " << sourceStackKey.second << " of tree " <<
         spacetreeId << " onto input stream " << targetStack <<
         " of tree " << targetId <<
         ". Copy " << stackContainer.getForPush(sourceStackKey)->size() << " entries"
      );

      stackContainer.getForPush(targetId,targetStack)->clone( *stackContainer.getForPop(sourceStackKey) );

      #if PeanoDebug>0
      const int comparisonStackForTarget = Node::getInstance().getOutputStackNumberForHorizontalDataExchange( spacetreeId );

      assertion8(
        stackContainer.getForPush(targetId,targetStack)->size() == stackContainer.getForPush(spacetreeId,comparisonStackForTarget)->size()
        or
        stackContainer.getForPush(spacetreeId,comparisonStackForTarget)->empty(),
        stackContainer.getForPush(targetId,targetStack)->size(),
        stackContainer.getForPush(spacetreeId,comparisonStackForTarget)->size(),
        stackContainer.getForPush(targetId,targetStack)->toString(),
        stackContainer.getForPush(spacetreeId,comparisonStackForTarget)->toString(),
        targetStack, comparisonStackForTarget, spacetreeId,
        "target stack is what I have already sent over"
      );
      #endif

      stackContainer.getForPush(sourceStackKey)->clear();
    }
  }
  logTraceOut( "exchangeAllHorizontalDataExchangeStacks(...)" );
}


template <class Container>
void peano4::parallel::SpacetreeSet::finishAllOutstandingSendsAndReceives( Container& stackContainer, int spacetreeId ) {
  logTraceInWith1Argument( "finishAllOutstandingSendsAndReceives(...)", spacetreeId );
  // Finalise data exchange
  // ----------------------
  std::set< peano4::maps::StackKey > keys = stackContainer.getKeys();

  clock_t      timeOutWarning   = -1;
  clock_t      timeOutShutdown  = -1;
  bool         triggeredTimeoutWarning = false;
  bool         allSendReceivesFinished = false;

  while (not allSendReceivesFinished) {
    allSendReceivesFinished = true;
    for (auto& sourceStackKey: keys) {
      if ( sourceStackKey.first==spacetreeId ) {
        logDebug( "finishAllOutstandingSendsAndReceives(...)", "check stack no " << sourceStackKey.first << " x " << sourceStackKey.second );
        allSendReceivesFinished &= stackContainer.getForPush(sourceStackKey)->tryToFinishSendOrReceive();
      }
    }

    if (timeOutWarning==-1)   timeOutWarning   = tarch::mpi::Rank::getInstance().getDeadlockWarningTimeStamp();
    if (timeOutShutdown==-1)  timeOutShutdown  = tarch::mpi::Rank::getInstance().getDeadlockTimeOutTimeStamp();
    if (
      tarch::mpi::Rank::getInstance().isTimeOutWarningEnabled() &&
      (clock()>timeOutWarning) &&
      (!triggeredTimeoutWarning)
    ) {
      tarch::mpi::Rank::getInstance().writeTimeOutWarning(
        "peano4::stacks::STDVectorStack<T>",
        "finishSendOrReceive()", spacetreeId, -1, -1
      );
             triggeredTimeoutWarning = true;
    }
    if (
      tarch::mpi::Rank::getInstance().isTimeOutDeadlockEnabled() &&
      (clock()>timeOutShutdown)
    ) {
      tarch::mpi::Rank::getInstance().triggerDeadlockTimeOut(
        "peano4::stacks::STDVectorStack<T>",
        "finishSendOrReceive()", spacetreeId, -1, -1
      );
    }
    tarch::mpi::Rank::getInstance().receiveDanglingMessages();
    tarch::multicore::yield();
  }

  logDebug( "finishAllOutstandingSendsAndReceives(...)", "all data transfer is done, trigger garbage collection" );

  stackContainer.garbageCollection();
  logTraceOutWith1Argument( "finishAllOutstandingSendsAndReceives(...)", spacetreeId );
}


template <class Container>
void peano4::parallel::SpacetreeSet::exchangeAllPeriodicBoundaryDataStacks( Container& stackContainer, int spacetreeId ) {
  std::set< peano4::maps::StackKey > keys = stackContainer.getKeys();
  for (auto& sourceStackKey: keys) {
    if (
      sourceStackKey.first==spacetreeId
      and
      Node::getInstance().isPeriodicBoundaryExchangeOutputStackNumber(sourceStackKey.second)
      and
      not stackContainer.getForPush(sourceStackKey)->empty()
    ) {
      const int targetStack = Node::getInstance().getPeriodicBoundaryExchangeInputStackNumberForOutputStack(sourceStackKey.second);
      logDebug(
         "exchangeStacksAsynchronously(...)",
         "map output stream " << sourceStackKey.second << " onto input stream " << targetStack <<
         " to realise periodic boundary conditions. Copy/clone " << stackContainer.getForPush(sourceStackKey)->size() << " entries"
      );
      logDebug(
         "exchangeStacksAsynchronously(...)",
         stackContainer.getForPush(sourceStackKey)->toString()
      );

      stackContainer.getForPush(sourceStackKey.first,targetStack)->clone( *stackContainer.getForPush(sourceStackKey) );
      stackContainer.getForPush(sourceStackKey)->clear();
    }
  }
}

