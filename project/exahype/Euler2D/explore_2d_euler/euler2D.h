//
// ExaHyPE2 solver file
// Generated by Peano's Python API
// www.peano-framework.org
//
// This is generated. If you change fundamental properties, you will have to 
// generate this file. Backup your manual changes before you do so.
//
#ifndef _project_explore_2d_euler_euler2D_H_
#define _project_explore_2d_euler_euler2D_H_

#include "Abstracteuler2D.h"
#include "tarch/logging/Log.h"

namespace project {namespace explore_2d_euler {
  class euler2D;

}}


class project::explore_2d_euler::euler2D: public Abstracteuler2D {
  private:
    static tarch::logging::Log   _log;

  public:
    


    
    void initialCondition(
      double * __restrict__ Q,
      const tarch::la::Vector<Dimensions,double>&  volumeCentre,
      const tarch::la::Vector<Dimensions,double>&  volumeH,
      bool                                         gridIsConstructred
    ) override;
    

    
    
    virtual void boundaryConditions(
      const double * __restrict__ Qinside, // Qinside[4+0]
      double * __restrict__ Qoutside, // Qoutside[4+0]
      const tarch::la::Vector<Dimensions,double>&  faceCentre,
      const tarch::la::Vector<Dimensions,double>&  volumeH,
      double                                       t,
      int                                          normal
    )  override;
    

    
  public:
    

    
    /**
     * Determine max eigenvalue over Jacobian in a given point with solution values
     * (states) Q. All parameters are in.
     *
     * @return Max eigenvalue. Result has to be positive, so we are actually speaking
     *   about the maximum absolute eigenvalue.
     */
    virtual double maxEigenvalue(
      const double * __restrict__ Q, // Q[4+0],
      const tarch::la::Vector<Dimensions,double>&  faceCentre,
      const tarch::la::Vector<Dimensions,double>&  volumeH,
      double                                       t,
      int                                          normal
    ) override;
    


    
    virtual void flux(
      const double * __restrict__ Q, // Q[4+0],
      const tarch::la::Vector<Dimensions,double>&  faceCentre,
      const tarch::la::Vector<Dimensions,double>&  volumeH,
      double                                       t,
      int                                          normal,
      double * __restrict__ F // F[4]
    ) override;
    
     
     
    
    
   
    


    


    
     
   
        
};


#endif