//
// ExaHyPE2 solver file
// Generated by Peano's Python API
// www.peano-framework.org
//
// This is generated. If you change fundamental properties, you will have to 
// generate this file. Backup your manual changes before you do so.
//
#ifndef _project_exahype_SWE_generated_swe_H_
#define _project_exahype_SWE_generated_swe_H_

#include "Abstractswe.h"
#include "tarch/logging/Log.h"

namespace project {namespace exahype {namespace SWE {namespace generated {
  class swe;

}}}}


class project::exahype::SWE::generated::swe: public Abstractswe {
  private:
    static tarch::logging::Log   _log;

  public:
    
    /**
     * Refinement criterion
     *
     * ExaHypE2 is guided by a maximum and minimum mesh (patch) size.
     * All (dynamic) AMR is constrained by these values, i.e. if your
     * mesh is coarser than the maximum mesh size, ExaHyPE 2 will
     * automatically refine. If you try to refine further than the
     * minimum mesh size, ExaHyPE 2 will ignore any refinement.
     *
     * Consequently, you are fine if you work with a regular mesh:
     * You set the maximum mesh size, and you leave everything else
     * to Peano 4/ExaHyPE 2. If you want to have an adaptive mesh,
     * use this routine to implement the refinement pattern.
     *
     * @param Q This is the (current) solution. The data is not set
     *  to a valid value throughout grid construction. That is: If
     *  t equals 0.0, you cannot assume that Q is properly initialised.
     *  Therefore, Q usually is only evaluated by dynamic AMR codes
     *  which make the solution follow
     */
    ::exahype2::RefinementCommand refinementCriterion(
      const double * __restrict__ Q, // Q[3+1],
      const tarch::la::Vector<Dimensions,double>&  volumeCentre,
      const tarch::la::Vector<Dimensions,double>&  volumeH,
      double                                       t
    ) override;
    


    
    void initialCondition(
      double * __restrict__ Q,
      const tarch::la::Vector<Dimensions,double>&  volumeCentre,
      const tarch::la::Vector<Dimensions,double>&  volumeH,
      bool                                         gridIsConstructred
    ) override;
    

    
    
    virtual void boundaryConditions(
      const double * __restrict__ Qinside, // Qinside[3+1]
      double * __restrict__ Qoutside, // Qoutside[3+1]
      const tarch::la::Vector<Dimensions,double>&  faceCentre,
      const tarch::la::Vector<Dimensions,double>&  volumeH,
      double                                       t,
      int                                          normal
    )  override;
    

    
  public:
    

    
    /**
     * Determine max eigenvalue over Jacobian in a given point with solution values
     * (states) Q. All parameters are in.
     *
     * @return Max eigenvalue. Result has to be positive, so we are actually speaking
     *   about the maximum absolute eigenvalue.
     */
    virtual double maxEigenvalue(
      const double * __restrict__ Q, // Q[3+1],
      const tarch::la::Vector<Dimensions,double>&  faceCentre,
      const tarch::la::Vector<Dimensions,double>&  volumeH,
      double                                       t,
      int                                          normal
    ) override;
    


    
    virtual void flux(
      const double * __restrict__ Q, // Q[3+1],
      const tarch::la::Vector<Dimensions,double>&  faceCentre,
      const tarch::la::Vector<Dimensions,double>&  volumeH,
      double                                       t,
      int                                          normal,
      double * __restrict__ F // F[3]
    ) override;
    
     
     
    
    virtual void nonconservativeProduct(
      const double * __restrict__ Q, // Q[3+1],
      const double * __restrict__             deltaQ, // [3+1]
      const tarch::la::Vector<Dimensions,double>&  faceCentre,
      const tarch::la::Vector<Dimensions,double>&  volumeH,
      double                                       t,
      int                                          normal,
      double * __restrict__ BgradQ // BgradQ[3]
    ) override;
    
    
   
    


    


    
     
   
        
};


#endif