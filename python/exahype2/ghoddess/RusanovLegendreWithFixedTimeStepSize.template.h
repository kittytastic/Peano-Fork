//
// ExaHyPE2 solver file
// Generated by Peano's Python API
// www.peano-framework.org
//
// This is generated. If you change fundamental properties, you will have to
// generate this file. Backup your manual changes before you do so.
//
#ifndef _{INCLUDE_GUARD}_
#define _{INCLUDE_GUARD}_


#include "exahype2/RefinementControl.h"

#include "tarch/la/Vector.h"

#include "peano4/utils/Globals.h"




{OPEN_NAMESPACE}
  class {CLASSNAME};
{CLOSE_NAMESPACE}



class {FULL_QUALIFIED_CLASSNAME} {{
  protected:
    double _timeStamp;

    /**
     * Determine whether a kernel shall be called
     */
    bool _projectOntoFace;
    bool _solveRiemann;
    bool _solveCell;
    bool _projectOntoCell;
  public:
    {CLASSNAME}();

    double getMinTimeStamp() const;
    double getMaxTimeStamp() const;
    double getMinTimeStepSize() const;
    double getMaxTimeStepSize() const;

    bool startNewTimeStepOnCellAndProjectOntoFace() const;
    bool solveRiemannProblem() const;
    bool solveCellProblem() const;
    bool projectRiemannSolutionOntoCellAndFinishTimeStepOnCell() const;

    /**
     * @param Q Vector of unknowns
     * @param t Time
     */
    ::exahype2::RefinementCommand refinementCriterion(
      double* Q,
      const tarch::la::Vector<Dimensions,double>&  cellCentre,
      const tarch::la::Vector<Dimensions,double>&  cellH,
      double                                       t
    );

    void adjustSolution(
      double* Q,
      const tarch::la::Vector<Dimensions,double>&  cellCentre,
      const tarch::la::Vector<Dimensions,double>&  cellH,
      double                                       t
    );

    void boundaryConditions(
      double* Q,
      const tarch::la::Vector<Dimensions,double>&  faceCentre,
      const tarch::la::Vector<Dimensions,double>&  faceH,
      double                                       t,
	  const tarch::la::Vector<Dimensions,double>&  normal
    );

    void projectOntoFace(
      double* QCell,
      double* QFace,
      const tarch::la::Vector<Dimensions,double>&  cellCentre,
      const tarch::la::Vector<Dimensions,double>&  cellH,
      int                                          faceNumber
    );

    void solveRiemannProblem(
      double* Q,
      const tarch::la::Vector<Dimensions,double>&  faceCentre,
      const tarch::la::Vector<Dimensions,double>&  faceH,
	  const tarch::la::Vector<Dimensions,double>&  normal,
      double                                       t
    );

    void solveCell(
      double* Q,
      const tarch::la::Vector<Dimensions,double>&  cellCentre,
      const tarch::la::Vector<Dimensions,double>&  cellH,
      double                                       t
    );

    void projectOntoCell(
      double* QCell,
      double* QFace,
      const tarch::la::Vector<Dimensions,double>&  cellCentre,
      const tarch::la::Vector<Dimensions,double>&  cellH,
      int                                          faceNumber
    );

    /**
     * If you hook into this routine, ensure the abstract base class
     * operation is still invoked.
     */
    virtual void startTimeStep(
      double globalMinTimeStamp,
      double globalMaxTimeStamp,
      double globalMinTimeStepSize,
      double globalMaxTimeStepSize
    );

    /**
     * If you hook into this routine, ensure the abstract base class
     * operation is still invoked.
     */
    virtual void finishTimeStep();
}};


#endif
