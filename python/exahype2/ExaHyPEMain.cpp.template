#include "{MAIN_NAME}.h"
#include "Constants.h"

#include "tarch/logging/Log.h"
#include "tarch/logging/LogFilter.h"
#include "tarch/logging/LogFilterFileReader.h"

#include "tarch/multicore/multicore.h"
#include "tarch/multicore/Core.h"

#include "peano4/peano.h"
#include "peano4/grid/Spacetree.h"
#include "peano4/parallel/SpacetreeSet.h"

#include "observers/DataRepository.h"
#include "observers/StepRepository.h"
#include "observers/SolverRepository.h"

#include "observers/CreateGrid.h"
#include "observers/PlotSolution.h"
#include "observers/TimeStep.h"

#include "peano4/UnitTests.h"
#include "tarch/UnitTests.h"
#include "exahype2/NonCriticalAssertions.h"



using namespace {FULL_NAMESPACE};



tarch::logging::Log _log("::");



/**
 * @return continues to run
 */
bool selectNextAlgorithmicStep() {{
  static bool   gridConstructed   = false;
  static double nextPlotTimeStamp = FirstPlotTimeStamp;
  static bool   haveJustWrittenSnapshot = false;
  static bool   haveReceivedNoncriticialAssertion = false;
  bool          continueToSolve   = true;

  if (exahype2::hasNonCriticalAssertionBeenViolated() and not haveReceivedNoncriticialAssertion) {{
    peano4::parallel::Node::getInstance().setNextProgramStep(
      observers::StepRepository::toProgramStep( observers::StepRepository::Steps::PlotSolution )
    );
    continueToSolve = true;
    haveReceivedNoncriticialAssertion = true;
    logError( "selectNextAlgorithmicStep()", "noncritical assertion has been triggered in code. Dump final state and terminate" );
  }}
  else if (exahype2::hasNonCriticalAssertionBeenViolated()) {{
    continueToSolve = false;
  }}
  else if (not gridConstructed) {{
    peano4::parallel::Node::getInstance().setNextProgramStep(
      observers::StepRepository::toProgramStep( observers::StepRepository::Steps::CreateGrid )
    );
    if ( peano4::parallel::SpacetreeSet::getInstance().getGridStatistics().getStationarySweeps()>=5 ) {{
      assertionNumericalEquals( observers::getMinTimeStamp(), 0.0 );
      gridConstructed = true;
    }}
    continueToSolve = true;
  }}
  else {{
    if ( observers::getMinTimeStamp()>=nextPlotTimeStamp  and TimeInBetweenPlots>0.0 ) {{
      nextPlotTimeStamp += TimeInBetweenPlots;
      if ( nextPlotTimeStamp < observers::getMinTimeStamp() ) {{
        logWarning( "selectNextAlgorithmicStep()", "code is asked to plot every dt=" << TimeInBetweenPlots << ", but this seems to be less than the minimal time step size of the solvers" );
        nextPlotTimeStamp = observers::getMinTimeStamp() + TimeInBetweenPlots;
        logWarning( "selectNextAlgorithmicStep()", "plot solution at t=" << observers::getMinTimeStamp() << ", but next plot will be due at t=" << nextPlotTimeStamp );
      }}
      peano4::parallel::Node::getInstance().setNextProgramStep(
        observers::StepRepository::toProgramStep( observers::StepRepository::Steps::PlotSolution )
      );
      haveJustWrittenSnapshot = true;
      continueToSolve = true;
    }}
    else if ( observers::getMinTimeStamp()<TerminalTime ) {{
      peano4::parallel::Node::getInstance().setNextProgramStep(
        observers::StepRepository::toProgramStep( observers::StepRepository::Steps::TimeStep )
      );
      continueToSolve = true;
      haveJustWrittenSnapshot = false;
    }}
    else {{
      if (not haveJustWrittenSnapshot and TimeInBetweenPlots>0.0) {{
        peano4::parallel::Node::getInstance().setNextProgramStep(
          observers::StepRepository::toProgramStep( observers::StepRepository::Steps::PlotSolution )
        );
        continueToSolve = true; // don't want to terminate immediately
        haveJustWrittenSnapshot = false;
      }}
      else {{
        continueToSolve = false;
      }}
    }}
  }}

  return continueToSolve;
}}


void step() {{
  int  stepIdentifier = peano4::parallel::Node::getInstance().getCurrentProgramStep();
  auto stepName       = observers::StepRepository::toStepEnum(stepIdentifier);

  static tarch::logging::Log _log("");
  logInfo( "step()", "run " << observers::StepRepository::toString(stepName) );

  switch ( stepName ) {{
    case observers::StepRepository::Steps::CreateGrid:
      {{
        observers::CreateGrid  observer;
        peano4::parallel::SpacetreeSet::getInstance().traverse(observer);
        observers::finishGridConstructionStep();
      }}
      break;
    case observers::StepRepository::Steps::PlotSolution:
      {{
        observers::PlotSolution  observer;
        peano4::parallel::SpacetreeSet::getInstance().traverse(observer);
      }}
      break;
    case observers::StepRepository::Steps::TimeStep:
      {{
        const double minTimeStamp    = observers::getMinTimeStamp();
        const double maxTimeStamp    = observers::getMaxTimeStamp();
        const double minTimeStepSize = observers::getMinTimeStepSize();
        const double maxTimeStepSize = observers::getMaxTimeStepSize();

        logInfo( "step()", "t_{{min}}  = " << minTimeStamp );
        logInfo( "step()", "t_{{max}}  = " << maxTimeStamp );
        logInfo( "step()", "dt_{{min}} = " << minTimeStepSize );
        logInfo( "step()", "dt_{{max}} = " << maxTimeStepSize );
        observers::startTimeStep( minTimeStamp, maxTimeStamp, minTimeStepSize, maxTimeStepSize );
        observers::TimeStep  observer;
        peano4::parallel::SpacetreeSet::getInstance().traverse(observer);
        observers::finishTimeStep();
      }}
      break;
  }}
}}


void setDefaultLogStatements() {{
    tarch::logging::LogFilter::getInstance().addFilterListEntry( tarch::logging::LogFilter::FilterListEntry(
      tarch::logging::LogFilter::FilterListEntry::TargetDebug, 
      tarch::logging::LogFilter::FilterListEntry::AnyRank, 
      "peano4", 
      tarch::logging::LogFilter::FilterListEntry::BlackListEntry
    ));
    tarch::logging::LogFilter::getInstance().addFilterListEntry( tarch::logging::LogFilter::FilterListEntry(
      tarch::logging::LogFilter::FilterListEntry::TargetTrace, 
      tarch::logging::LogFilter::FilterListEntry::AnyRank, 
      "peano4", 
      tarch::logging::LogFilter::FilterListEntry::BlackListEntry
    ));
    tarch::logging::LogFilter::getInstance().addFilterListEntry( tarch::logging::LogFilter::FilterListEntry(
      tarch::logging::LogFilter::FilterListEntry::TargetInfo, 
      tarch::logging::LogFilter::FilterListEntry::AnyRank, 
      "peano4", 
      tarch::logging::LogFilter::FilterListEntry::WhiteListEntry
    ));
  
   tarch::logging::LogFilter::getInstance().addFilterListEntry( tarch::logging::LogFilter::FilterListEntry(
       tarch::logging::LogFilter::FilterListEntry::TargetDebug, 
      tarch::logging::LogFilter::FilterListEntry::AnyRank, 
      "tarch", 
      tarch::logging::LogFilter::FilterListEntry::BlackListEntry
    ));
    tarch::logging::LogFilter::getInstance().addFilterListEntry( tarch::logging::LogFilter::FilterListEntry(
      tarch::logging::LogFilter::FilterListEntry::TargetTrace, 
      tarch::logging::LogFilter::FilterListEntry::AnyRank, 
     "tarch", 
      tarch::logging::LogFilter::FilterListEntry::BlackListEntry
    ));
    tarch::logging::LogFilter::getInstance().addFilterListEntry( tarch::logging::LogFilter::FilterListEntry(
      tarch::logging::LogFilter::FilterListEntry::TargetInfo, 
      tarch::logging::LogFilter::FilterListEntry::AnyRank, 
      "tarch", 
      tarch::logging::LogFilter::FilterListEntry::WhiteListEntry
    ));

    tarch::logging::LogFilter::getInstance().addFilterListEntry( tarch::logging::LogFilter::FilterListEntry(
      tarch::logging::LogFilter::FilterListEntry::TargetDebug,
      tarch::logging::LogFilter::FilterListEntry::AnyRank,
      "{FULL_NAMESPACE}",
      tarch::logging::LogFilter::FilterListEntry::BlackListEntry
    ));
    tarch::logging::LogFilter::getInstance().addFilterListEntry( tarch::logging::LogFilter::FilterListEntry(
      tarch::logging::LogFilter::FilterListEntry::TargetTrace,
      tarch::logging::LogFilter::FilterListEntry::AnyRank,
      "{FULL_NAMESPACE}",
      tarch::logging::LogFilter::FilterListEntry::BlackListEntry
    ));
    tarch::logging::LogFilter::getInstance().addFilterListEntry( tarch::logging::LogFilter::FilterListEntry(
      tarch::logging::LogFilter::FilterListEntry::TargetInfo,
      tarch::logging::LogFilter::FilterListEntry::AnyRank,
      "{FULL_NAMESPACE}",
      tarch::logging::LogFilter::FilterListEntry::WhiteListEntry
    ));

    tarch::logging::LogFilter::getInstance().addFilterListEntry( tarch::logging::LogFilter::FilterListEntry(
      tarch::logging::LogFilter::FilterListEntry::TargetDebug, 
      tarch::logging::LogFilter::FilterListEntry::AnyRank, 
      "exahype2",
      tarch::logging::LogFilter::FilterListEntry::BlackListEntry
    ));
    tarch::logging::LogFilter::getInstance().addFilterListEntry( tarch::logging::LogFilter::FilterListEntry(
      tarch::logging::LogFilter::FilterListEntry::TargetTrace, 
      tarch::logging::LogFilter::FilterListEntry::AnyRank, 
      "exahype2",
      tarch::logging::LogFilter::FilterListEntry::BlackListEntry
    ));
    tarch::logging::LogFilter::getInstance().addFilterListEntry( tarch::logging::LogFilter::FilterListEntry(
      tarch::logging::LogFilter::FilterListEntry::TargetInfo, 
      tarch::logging::LogFilter::FilterListEntry::AnyRank, 
      "exahype2",
      tarch::logging::LogFilter::FilterListEntry::WhiteListEntry
    ));

    tarch::logging::LogFilter::getInstance().addFilterListEntry( tarch::logging::LogFilter::FilterListEntry(
      tarch::logging::LogFilter::FilterListEntry::TargetDebug, 
      tarch::logging::LogFilter::FilterListEntry::AnyRank, 
      "toolbox",
      tarch::logging::LogFilter::FilterListEntry::BlackListEntry
    ));
    tarch::logging::LogFilter::getInstance().addFilterListEntry( tarch::logging::LogFilter::FilterListEntry(
      tarch::logging::LogFilter::FilterListEntry::TargetTrace, 
      tarch::logging::LogFilter::FilterListEntry::AnyRank, 
      "toolbox",
      tarch::logging::LogFilter::FilterListEntry::BlackListEntry
    ));
    tarch::logging::LogFilter::getInstance().addFilterListEntry( tarch::logging::LogFilter::FilterListEntry(
      tarch::logging::LogFilter::FilterListEntry::TargetInfo, 
      tarch::logging::LogFilter::FilterListEntry::AnyRank, 
      "toolbox",
      tarch::logging::LogFilter::FilterListEntry::WhiteListEntry
    ));
}}  


void printUsage(char** argv) {{
  std::cout << "Usage: ./" << argv[0] << " [options]" << std::endl <<
"ExaHyPE 2 - an Exascale Hyperbolic PDE Engine (version 2) \n\
www.peano-framework.org \n\
\n \
Options: \n\
  -h, --help                 Display help on commandline options. \n\
  --threads <no>             Specify how many threads to use (per rank). Option \n\
                             has no meaning if code base has not been \n\
                             translated with shared memory support. \n\
  --log-filter-file <file>   Specify which log filter file to use. Default file \n\
                             is exahype.log-filter \n\
  --timeout <t>              Set timeout. t is given in seconds and can be 0 to \n\
                             switch timeouts off. \n\
";
}}
  
  
int main(int argc, char** argv) {{
  const int ExitCodeSuccess         = 0;
  const int ExitCodeUnitTestsFailed = 1;
  
  if (
    (argc==2 and std::string(argv[1]).compare( "--help" )!=std::string::npos)
    or
    (argc==2 and std::string(argv[1]).compare( "-h" )!=std::string::npos)
    or
    (argc%2!=1)
  ) {{
    printUsage(argv);
    return 1;
  }}
  
  std::string logFilterFile = "exahype.log-filter";
  int         cores         = tarch::multicore::Core::UseDefaultNumberOfThreads;

  for (int argument=1; argument<argc; argument+=2) {{
    std::string select = argv[argument];
    if ( select.compare( "--threads" ) != std::string::npos ) {{
      cores = std::atoi(argv[argument+1]);
      tarch::multicore::Core::getInstance().configure( cores );
    }}
    else if ( select.compare( "--log-filter-file" ) != std::string::npos ) {{
      logFilterFile = argv[argument+1];
    }}
    else {{
      printUsage(argv);
      return 1;
    }}
  }}
  
  if ( not tarch::logging::LogFilterFileReader::parsePlainTextFile( logFilterFile ) ) {{
    logWarning( "main()", "no exahype.log-filter file found or file has been corrupted. Use default logging configuration" );
    setDefaultLogStatements();
  }}
  
  peano4::initParallelEnvironment(&argc,&argv);
  exahype2::initNonCritialAssertionEnvironment();
  peano4::fillLookupTables();
  
  {FULL_NAMESPACE}::observers::DataRepository::initDatatypes();
  

  #if PeanoDebug>=2
  tarch::tests::TestCase* peanoCoreTests = peano4::getUnitTests();
  peanoCoreTests->run();
  if (peanoCoreTests->getNumberOfErrors() != 0) {{
    logError("main()", "Peano4 core unit tests failed. Quit.");
    tarch::mpi::Rank::abort( ExitCodeUnitTestsFailed );
  }}
  delete peanoCoreTests;

  tarch::tests::TestCase* peanoTarchTests = tarch::getUnitTests();
  peanoTarchTests->run();
  if (peanoTarchTests->getNumberOfErrors() != 0) {{
    logError("main()", "technical architecture (tarch) unit tests failed. Quit.");
    tarch::mpi::Rank::abort( ExitCodeUnitTestsFailed );
  }}
  delete peanoTarchTests;
 
  #endif

  peano4::parallel::SpacetreeSet::getInstance().init(
    DomainOffset,
	DomainSize,
    0
  );
  if (tarch::mpi::Rank::getInstance().isGlobalMaster() ) {{
    while ( selectNextAlgorithmicStep() ) {{
      step();
    }}
  }}
  else {{
    while (peano4::parallel::Node::getInstance().continueToRun()) {{
      step();
    }}
  }}

  {FULL_NAMESPACE}::observers::DataRepository::shutdownDatatypes();
  exahype2::shutdownNonCritialAssertionEnvironment();
  peano4::shutdownParallelEnvironment();

  return ExitCodeSuccess;
}}
