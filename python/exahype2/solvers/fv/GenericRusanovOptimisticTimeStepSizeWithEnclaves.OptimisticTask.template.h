//
// ExaHyPE2 solver file
// Generated by Peano's Python API
// www.peano-framework.org
//
// This is generated. Don't change it! Every rerun of the Python API will
// overwrite your changes.
//
#ifndef {% for item in NAMESPACE -%}_{{ item }}{%- endfor %}_{{CLASSNAME}}_H_
#define {% for item in NAMESPACE -%}_{{ item }}{%- endfor %}_{{CLASSNAME}}_H_


#include "peano4/datamanagement/CellMarker.h"
#include "tarch/multicore/Tasks.h"


#include "exahype2/fv/Generic.h"
#include "exahype2/fv/Rusanov.h"
#include "exahype2/EnclaveBookkeeping.h"
#include "exahype2/EnclaveTask.h"
#include "peano4/parallel/Tasks.h"
#include "repositories/SolverRepository.h"


#include <vector>


{% for item in NAMESPACE -%}
  namespace {{ item }} {

{%- endfor %}
  class {{CLASSNAME}};

{% for item in NAMESPACE -%}
  }
{%- endfor %}



/**
 * Single task that can also take multiple tasks and deploy them to the GPU
 *
 * @author ExaHyPE's code generator written by Holger Schulz and Tobias Weinzierl 
 */
class {{NAMESPACE | join("::")}}::{{CLASSNAME}}: public ::exahype2::EnclaveTask {
  private:
    static tarch::logging::Log  _log;
    static int                  _optimisticTaskId;
    
    /**
     * We have to work with a copy of the patch data, as the patch data's
     * location might change later
     */
    static double* copyPatchData( double* __restrict__ patchData);
    
  public:
    /**
     * @param patchData This is the real patch data, i.e. NxNxN. No outer halo or so.
     */
    {{CLASSNAME}}(
      const ::peano4::datamanagement::CellMarker& marker, 
      double                                      t,
      double                                      dt,
      double                                      predictedTimeStepSize,
      double* __restrict__                        patchData
    );
    
    static void mergeTaskOutcomeIntoPatch(
      int taskNumber,
      double* __restrict__                        reconstructedPatch
    );

    static void applyKernelToCellBoundary(
      const ::peano4::datamanagement::CellMarker& marker, 
      double                                      t,
      double                                      dt,
      double* __restrict__                        reconstructedPatch,
      double* __restrict__                        patchData
    );
};



#endif
