//
// ExaHyPE2 solver file
// Generated by Peano's Python API
// www.peano-framework.org
//
// This is generated. Don't change it! Every rerun of the Python API will
// overwrite your changes.
//
#ifndef {% for item in NAMESPACE -%}_{{ item }}{%- endfor %}_{{CLASSNAME}}_H_
#define {% for item in NAMESPACE -%}_{{ item }}{%- endfor %}_{{CLASSNAME}}_H_


#include "exahype2/RefinementControl.h"
#include "exahype2/Solver.h"

#include "tarch/la/Vector.h"

#include "peano4/utils/Globals.h"

#include "Constants.h"



{% for item in NAMESPACE -%}
  namespace {{ item }} {

{%- endfor %}
  class {{CLASSNAME}};

{% for item in NAMESPACE -%}
  }
{%- endfor %}



class {{NAMESPACE | join("::")}}::{{CLASSNAME}}: public ::exahype2::Solver {
  public:
    enum class SolverState {
      GridConstruction,
      GridInitialisation,
      PrimaryAfterGridInitialisation,
      Primary,
      Secondary,
      PlottingInitialCondition,
      Plotting
    };

    static std::string toString(SolverState);

    {{CLASSNAME}}();

    /**
     * Determine max eigenvalue over Jacobian in a given point with solution values
     * (states) Q. All parameters are in.
     *
     * @return Max eigenvalue. Result has to be positive, so we are actually speaking
     *   about the maximum absolute eigenvalue.
     */
    virtual double maxEigenvalue(
      const double * __restrict__ Q, // Q[{{NUMBER_OF_UNKNOWNS}}+{{NUMBER_OF_AUXILIARY_VARIABLES}}],
      const tarch::la::Vector<Dimensions,double>&  faceCentre,
      const tarch::la::Vector<Dimensions,double>&  volumeH,
      double                                       t,
      int                                          normal
    ) {% if EIGENVALUES_IMPLEMENTATION=="<user-defined>" %}= 0{% else %} final{% endif %};


    {% if FLUX_IMPLEMENTATION!="<none>" %}
    virtual void flux(
      const double * __restrict__ Q, // Q[{{NUMBER_OF_UNKNOWNS}}+{{NUMBER_OF_AUXILIARY_VARIABLES}}],
      const tarch::la::Vector<Dimensions,double>&  faceCentre,
      const tarch::la::Vector<Dimensions,double>&  volumeH,
      double                                       t,
      int                                          normal,
      double * __restrict__ F // F[{{NUMBER_OF_UNKNOWNS}}]
    ) {% if FLUX_IMPLEMENTATION=="<user-defined>" %}=0{% else %} final {% endif %};
    {% endif %}


    {% if NCP_IMPLEMENTATION!="<none>" %}
    virtual void nonconservativeProduct(
      const double * __restrict__                  Q,      // Q[{{NUMBER_OF_UNKNOWNS}}+{{NUMBER_OF_AUXILIARY_VARIABLES}}],
      const double * __restrict__                  deltaQ,   // Q[{{NUMBER_OF_UNKNOWNS}}+{{NUMBER_OF_AUXILIARY_VARIABLES}}],
      const tarch::la::Vector<Dimensions,double>&  faceCentre,
      const tarch::la::Vector<Dimensions,double>&  volumeH,
      double                                       t,
      int                                          normal,
      double * __restrict__ BgradQ // BgradQ[{{NUMBER_OF_UNKNOWNS}}]
    ) {% if NCP_IMPLEMENTATION=="<user-defined>" %}=0{% endif %};
    {% endif %}


    virtual void sourceTerm(
      const double * __restrict__ Q,
      const tarch::la::Vector<Dimensions,double>&  volumeCentre,
      const tarch::la::Vector<Dimensions,double>&  volumeH,
      double                                       t,
      double                                       dt,
      double * __restrict__ S
    ) {% if SOURCE_TERM_IMPLEMENTATION=="<user-defined>" %}= 0{% else %} final {% endif %};

     
    {% include "AbstractSolverAdaptiveTimeStepSize.template.h" %}
  private:
    /**
     * This value is required for to extrapolate how the time step 
     * size changes in the future, i.e. it is reqiured for our biased
     * time step choice.
     */
    double _previousAdmissibleTimeStepSize;
    
    /**
     * The adaptive time stepping reduces the admissible time step size
     * in its field _admissibleTimeStepSize. As we have enclave tasks from
     * two different time steps active at any time, I backup the 
     * admissible time step size and continue to reduce. This way, I get a
     * mixture, but that's the price to pay for the increase of 
     * asynchronicity.
     */
    double _admissibleTimeStepSizeAfterPrimaryGridSweep;
    
    /**
     * The _timeStepSize is fixed from the start of the primary sweep till
     * the end of the secondary one. If the predicted time step size is set
     * to zero (or smaller), then we do not issue any optimistic time step 
     * sizes and we also have to undo any time steps used before.
     *
     * In the secondary sweep, we use the predictedTimeStepSize (if it is
     * bigger than zero) to issue some tasks optimistically. After the 
     * secondary grid sweep, we roll over the predictedTimeStepSize into 
     * _timeStepSize if it had been admissible. If it has not been admissible,
     * we set _timeStepSize to the valid one and reset the predicted value 
     * to zero.
     */
    double _predictedTimeStepSize;
};


#endif
