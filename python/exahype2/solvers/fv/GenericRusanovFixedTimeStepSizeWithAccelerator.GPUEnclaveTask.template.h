//
// ExaHyPE2 solver file
// Generated by Peano's Python API
// www.peano-framework.org
//
// This is generated. Don't change it! Every rerun of the Python API will
// overwrite your changes.
//
#ifndef {% for item in NAMESPACE -%}_{{ item }}{%- endfor %}_{{CLASSNAME}}_H_
#define {% for item in NAMESPACE -%}_{{ item }}{%- endfor %}_{{CLASSNAME}}_H_


#include "peano4/datamanagement/CellMarker.h"
#include "tarch/multicore/Tasks.h"


#include "exahype2/fv/Generic.h"
#include "exahype2/fv/Rusanov.h"
#include "exahype2/EnclaveBookkeeping.h"
#include "exahype2/EnclaveTask.h"
#include "peano4/parallel/Tasks.h"
#include "repositories/SolverRepository.h"


#include <vector>


{% for item in NAMESPACE -%}
  namespace {{ item }} {

{%- endfor %}
  class {{CLASSNAME}};

{% for item in NAMESPACE -%}
  }
{%- endfor %}



/**
 * Single task that can also take multiple tasks and deploy them to the GPU
 *
 * @author ExaHyPE's code generator written by Holger Schulz and Tobias Weinzierl 
 */
class {{NAMESPACE | join("::")}}::{{CLASSNAME}}: public tarch::multicore::Task {
  private:
    friend class EnclaveBookkeeping;

    static tarch::logging::Log                _log;
    static int                                _gpuEnclaveTaskId;

    const ::peano4::datamanagement::CellMarker   _marker;
    const double                                 _t;
    const double                                 _dt;
    double*                                      _reconstructedValues;

    #if Dimensions==2
    const int _destinationPatchSize = {{NUMBER_OF_VOLUMES_PER_AXIS}}*{{NUMBER_OF_VOLUMES_PER_AXIS}}*({{NUMBER_OF_UNKNOWNS}}+{{NUMBER_OF_AUXILIARY_VARIABLES}});
    const int _sourcePatchSize      = ({{NUMBER_OF_VOLUMES_PER_AXIS}}+2)*({{NUMBER_OF_VOLUMES_PER_AXIS}}+2)*({{NUMBER_OF_UNKNOWNS}}+{{NUMBER_OF_AUXILIARY_VARIABLES}});
    #elif Dimensions==3
    const int _destinationPatchSize = {{NUMBER_OF_VOLUMES_PER_AXIS}}*{{NUMBER_OF_VOLUMES_PER_AXIS}}*{{NUMBER_OF_VOLUMES_PER_AXIS}}*({{NUMBER_OF_UNKNOWNS}}+{{NUMBER_OF_AUXILIARY_VARIABLES}});
    const int _sourcePatchSize      = ({{NUMBER_OF_VOLUMES_PER_AXIS}}+2)*({{NUMBER_OF_VOLUMES_PER_AXIS}}+2)*({{NUMBER_OF_VOLUMES_PER_AXIS}}+2)*({{NUMBER_OF_UNKNOWNS}}+{{NUMBER_OF_AUXILIARY_VARIABLES}});
    #endif

  public:
    /**
     * Process one cell
     *
     * Use this one directly for the skelton cells, e.g. (therefore I made it 
     * static) or call it per enclave cell. Basically does three things:
     * 
     * - copy over the patch content into the new time step
     * - apply solvers
     * - free reconstructed memory
     */
    static void applyKernelToCell(
      const ::peano4::datamanagement::CellMarker& marker, 
      double                                      t,
      double                                      dt,
      double* __restrict__                        reconstructedPatch, 
      double* __restrict__                        targetPatch
    );

    /**
     * Create plain enclave task.
     *
     * @param inputValues Has to be created on heap via tarch::multicore::allocateMemory().
     */
    {{CLASSNAME}}(
      const ::peano4::datamanagement::CellMarker&    marker,
      double                                         t,
      double                                         dt,
      double*                                        reconstructedValues
    );

    {{CLASSNAME}}(const {{CLASSNAME}}& other) = delete;
    {{CLASSNAME}}(const {{CLASSNAME}}&& other) = delete;

    /**
     * This is a plain invocation of an enclave task
     */
    bool run() override;

    bool fuse( const std::list<Task*>& otherTasks ) override;
    
    bool canFuse() const override;
};



#endif
