//
// ExaHyPE2 solver file
// Generated by Peano's Python API
// www.peano-framework.org
//
// This is generated. Don't change it! Every rerun of the Python API will
// overwrite your changes.
//
#ifndef {% for item in NAMESPACE -%}_{{ item }}{%- endfor %}_{{CLASSNAME}}_H_
#define {% for item in NAMESPACE -%}_{{ item }}{%- endfor %}_{{CLASSNAME}}_H_


#include "peano4/datamanagement/CellMarker.h"
#include "tarch/multicore/Tasks.h"


#include "exahype2/fv/Generic.h"
#include "exahype2/fv/Rusanov.h"
#include "exahype2/EnclaveBookkeeping.h"
#include "exahype2/EnclaveTask.h"
#include "peano4/parallel/Tasks.h"
#include "repositories/SolverRepository.h"


#include <vector>


{% for item in NAMESPACE -%}
  namespace {{ item }} {

{%- endfor %}
  class {{CLASSNAME}};

{% for item in NAMESPACE -%}
  }
{%- endfor %}



class {{NAMESPACE | join("::")}}::{{CLASSNAME}}: public tarch::multicore::Task {
  private:
    friend class EnclaveBookkeeping;

    static tarch::logging::Log                _log;
    static int                                _gpuEnclaveTaskId;

    const ::peano4::datamanagement::CellMarker&  _marker;
    const double                                 _t;
    const double                                 _dt;
    const double*                                _reconstructedValues;

    #if Dimensions==2
    const int _destinationPatchSize = {{NUMBER_OF_VOLUMES_PER_AXIS}}*{{NUMBER_OF_VOLUMES_PER_AXIS}}*({{NUMBER_OF_UNKNOWNS}}+{{NUMBER_OF_AUXILIARY_VARIABLES}});
    const int _sourcePatchSize      = ({{NUMBER_OF_VOLUMES_PER_AXIS}}+2)*({{NUMBER_OF_VOLUMES_PER_AXIS}}+2)*({{NUMBER_OF_UNKNOWNS}}+{{NUMBER_OF_AUXILIARY_VARIABLES}});
    typedef std::vector<std::tuple<double*, const double, int, double, double, double, double> > PatchContainer;
    #elif Dimensions==3
    const int _destinationPatchSize = {{NUMBER_OF_VOLUMES_PER_AXIS}}*{{NUMBER_OF_VOLUMES_PER_AXIS}}*{{NUMBER_OF_VOLUMES_PER_AXIS}}*({{NUMBER_OF_UNKNOWNS}}+{{NUMBER_OF_AUXILIARY_VARIABLES}});
    const int _sourcePatchSize      = ({{NUMBER_OF_VOLUMES_PER_AXIS}}+2)*({{NUMBER_OF_VOLUMES_PER_AXIS}}+2)*({{NUMBER_OF_VOLUMES_PER_AXIS}}+2)*({{NUMBER_OF_UNKNOWNS}}+{{NUMBER_OF_AUXILIARY_VARIABLES}});
    typedef std::vector<std::tuple<double*, const double, int, double, double, double, double, double, double> > PatchContainer;
    #endif



  public:
    static void applyKernelToCell(
      const ::peano4::datamanagement::CellMarker& marker, 
      double                                      t,
      double                                      dt,
      double* __restrict__                        reconstructedPatch, 
      double* __restrict__                        targetPatch
    );

    /**
     * Create plain enclave task.
     *
     * @param inputValues Has to be created on heap via tarch::multicore::allocateMemory().
     */
    {{CLASSNAME}}(
      const ::peano4::datamanagement::CellMarker&    marker,
      double                                         t,
      double                                         dt,
      double*                                        reconstructedValues
    );

    {{CLASSNAME}}(const {{CLASSNAME}}& other) = delete;
    {{CLASSNAME}}(const {{CLASSNAME}}&& other) = delete;

    bool run() override;

    bool fuse( const std::list<Task*>& otherTasks ) override;
};



#endif
