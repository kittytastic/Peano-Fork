//
// ExaHyPE2 solver file
// Generated by Peano's Python API
// www.peano-framework.org
//
// This is generated. If you change fundamental properties, you will have to 
// generate this file. Backup your manual changes before you do so.
//
#ifndef _{INCLUDE_GUARD}_
#define _{INCLUDE_GUARD}_


#include "exahype2/RefinementControl.h"

#include "tarch/la/Vector.h"

#include "peano4/utils/Globals.h"




{OPEN_NAMESPACE}
  class {CLASSNAME};
{CLOSE_NAMESPACE}



class {FULL_QUALIFIED_CLASSNAME} {{
  protected:
    double _timeStamp;
  public:
    {CLASSNAME}();

    double getMinTimeStamp() const;
    double getMaxTimeStamp() const;
    double getMinTimeStepSize() const;
    double getMaxTimeStepSize() const;

    /**
     * @param Q Vector of unknowns
     * @param t Time
     */
    virtual ::exahype2::RefinementCommand refinementCriterion(
      double Q[{NUMBER_OF_UNKNOWNS}],
      const tarch::la::Vector<Dimensions,double>&  volumeCentre,
      const tarch::la::Vector<Dimensions,double>&  volumeH,
      double                                       t
    ) = 0;

    /**
     * Feel free to change the solution in the particular finite volume.
     * You can for example change the initial conditions by overwriting
     * the solution for t=0. You may change Q. All other parameters are
     * in.
     */
    virtual void adjustSolution(
      double Q[{NUMBER_OF_UNKNOWNS}],
      const tarch::la::Vector<Dimensions,double>&  volumeCentre,
      const tarch::la::Vector<Dimensions,double>&  volumeH,
      double                                       t
    ) = 0;

    /**
     * Determine eigenvalues over Jacobian in a given point with solution values
     * (states) Q. All parameters are in besides lambda which is the output
     * vector.
     */
    virtual void eigenvalues(
      double                                       Q[{NUMBER_OF_UNKNOWNS}],
      const tarch::la::Vector<Dimensions,double>&  faceCentre,
      const tarch::la::Vector<Dimensions,double>&  volumeH,
      double                                       t,
      int                                          normal,
      double                                       lambda[{NUMBER_OF_UNKNOWNS}]
    ) = 0;

    /**
     * Apply boundary conditions. You can overwrite both the inside and
     * outside values though most BCs only modify the outside ones. Please
     * note that the boundary conditions you set here are after that subject
     * to the Riemann solver, i.e. flux and eigenvalues.
     */
    virtual void boundaryConditions(
      double                                       Qinside[{NUMBER_OF_UNKNOWNS}],
      double                                       Qoutside[{NUMBER_OF_UNKNOWNS}],
      const tarch::la::Vector<Dimensions,double>&  faceCentre,
      const tarch::la::Vector<Dimensions,double>&  volumeH,
      double                                       t,
      int                                          normal
    ) = 0;

    /**
     * If you hook into this routine, ensure the abstract base class
     * operation is still invoked.
     */
    virtual void startTimeStep(
      double globalMinTimeStamp,
      double globalMaxTimeStamp,
      double globalMinTimeStepSize,
      double globalMaxTimeStepSize
    );

    /**
     * If you hook into this routine, ensure the abstract base class
     * operation is still invoked.
     */
    virtual void finishTimeStep();

{ABSTRACT_FLUX_FUNCTIONS}
}};


#endif
