#include "{CLASSNAME}.h"


// Some MPI routines require the loops
#include "peano4/utils/Loop.h"


 
{FULL_QUALIFIED_CLASSNAME}::{CLASSNAME}() {{
}}


{FULL_QUALIFIED_CLASSNAME}::{CLASSNAME}(const {CLASSNAME}& other) {{
  #if PeanoDebug>=1
  _debugX = other._debugX;
  _debugH = other._debugH;
  #endif

  #if Dimensions==2
  std::copy(other.value, other.value+{CARDINALITY_2D},value);
  #else
  std::copy(other.value, other.value+{CARDINALITY_3D},value);
  #endif
}}


{FULL_QUALIFIED_CLASSNAME}& {FULL_QUALIFIED_CLASSNAME}::operator=(const {CLASSNAME}& other) {{
  #if PeanoDebug>=1
  _debugX = other._debugX;
  _debugH = other._debugH;
  #endif
  
  #if Dimensions==2
  std::copy(other.value, other.value+{CARDINALITY_2D},value);
  #else
  std::copy(other.value, other.value+{CARDINALITY_3D},value);
  #endif
  return *this;
}}


std::string {FULL_QUALIFIED_CLASSNAME}::toString() const {{
  std::string result = std::string("()");
  return result;
}}


#ifdef PeanoDebug

void {FULL_QUALIFIED_CLASSNAME}::setDebugX( const tarch::la::Vector<Dimensions,double>& data ) {{
  _debugX = data;
}}


void {FULL_QUALIFIED_CLASSNAME}::setDebugH( const tarch::la::Vector<Dimensions,double>& data ) {{
  _debugH = data;
}}


tarch::la::Vector<Dimensions,double> {FULL_QUALIFIED_CLASSNAME}::getDebugX() const {{
  return _debugX;
}}


tarch::la::Vector<Dimensions,double> {FULL_QUALIFIED_CLASSNAME}::getDebugH() const {{
  return _debugH;
}}

#endif


{MERGE_METHOD_DEFINITIONS}

