//
// Peano4 data file
// Generated by Peano's Python API
// www.peano-framework.org
// This is generated. Be careful with adding your own stuff
//
#ifndef {% for item in NAMESPACE -%}_{{ item }}{%- endfor %}_{{CLASSNAME}}_H_
#define {% for item in NAMESPACE -%}_{{ item }}{%- endfor %}_{{CLASSNAME}}_H_



#include <string>

#include "tarch/la/Vector.h"
#include "tarch/mpi/mpi.h"

#include "peano4/utils/Globals.h"

#include "peano4/datamanagement/CellMarker.h"
#include "peano4/datamanagement/FaceMarker.h"
#include "peano4/datamanagement/VertexMarker.h"


{% for item in NAMESPACE -%}
  namespace {{ item }} {
{%- endfor %}

  class {{CLASSNAME}};

{% for item in NAMESPACE -%}
  }
{%- endfor %}



struct {% for item in NAMESPACE -%}{{ item }}::{%- endfor %}{{CLASSNAME}} {
  #if PeanoDebug>=1
  private:
    tarch::la::Vector<Dimensions,double> _debugX;
    tarch::la::Vector<Dimensions,double> _debugH;
  
  public:
    void setDebugX( const tarch::la::Vector<Dimensions,double>& data );
    void setDebugH( const tarch::la::Vector<Dimensions,double>& data );
    tarch::la::Vector<Dimensions,double> getDebugX() const;
    tarch::la::Vector<Dimensions,double> getDebugH() const;
  #endif

  #if Dimensions==2
  double                                 value[{{CARDINALITY_2D}}];
  #else
  double                                 value[{{CARDINALITY_3D}}];
  #endif
  
  {{CLASSNAME}}();
  {{CLASSNAME}}(const {{CLASSNAME}}& other);
  {{CLASSNAME}}& operator=(const {{CLASSNAME}}& other);

  std::string toString() const;
  
  {% if DATA_ASSOCIATION == 1 -%}
  void merge(const {{CLASSNAME}}& neighbour, const peano4::datamanagement::VertexMarker& marker);
  static bool send(const peano4::datamanagement::VertexMarker& marker);
  static bool receiveAndMerge(const peano4::datamanagement::VertexMarker& marker);
  static bool storePersistently(const peano4::datamanagement::VertexMarker& marker);
  static bool loadPersistently(const peano4::datamanagement::VertexMarker& marker);
  {% endif -%}

  {% if DATA_ASSOCIATION == 2 -%}
  void merge(const {{CLASSNAME}}& neighbour, const peano4::datamanagement::FaceMarker& marker);
  static bool send(const peano4::datamanagement::FaceMarker& marker);
  static bool receiveAndMerge(const peano4::datamanagement::FaceMarker& marker);
  static bool storePersistently(const peano4::datamanagement::FaceMarker& marker);
  static bool loadPersistently(const peano4::datamanagement::FaceMarker& marker);
  {% endif -%}

  {% if DATA_ASSOCIATION == 3 -%}
  void merge(const {{CLASSNAME}}& neighbour, const peano4::datamanagement::CellMarker& marker);
  static bool send(const peano4::datamanagement::CellMarker& marker);
  static bool receiveAndMerge(const peano4::datamanagement::CellMarker& marker);
  static bool storePersistently(const peano4::datamanagement::CellMarker& marker);
  static bool loadPersistently(const peano4::datamanagement::CellMarker& marker);
  {% endif -%}
  
  
  
  #ifdef Parallel
  /**
   * Sets the Datatype to MPI_Double.
   */
  static void initDatatype();

  /**
   * Degenerates to nop here, but we need such a function to fit to all other types.
   */
  static void shutdownDatatype();
  
  /**
   * Map each entry to an MPI_DOUBLE.
   */
  static MPI_Datatype   Datatype;
  #endif
};


#endif
