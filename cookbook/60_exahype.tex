\chapter{\ExaHyPE}
\label{section:python-api-examples:finite-volumes}


\begin{figure}[htb]
 \begin{center}
  \includegraphics[width=0.2\textwidth]{60_exahype/EU.png}
 \end{center}
 \caption{
   The original ExaHyPE project delivering the first generation of the ExaHyPE
   software has received funding from the European Unionâ€™s Horizon 2020 research
   and innovation programme under grant agreement No 671698 (ExaHyPE).
 }
\end{figure}

\noindent
\ExaHyPE\ is the follow-up development of the ExaHyPE project which has been
funded by the EU from 2015--2019.
The present version is the second generation of the code (\ExaHyPE) and has
seen substantial rewrites of core routines.
However, many paradigms and even code blocks remain the same.
Migrating from the original ExaHyPE to \ExaHyPE\ thus should be straightforward.


\ExaHyPE\ is both a set of C/C++ and Fortran core routines complementing the
\Peano\ core and a high-level augmentation of \Peano's Python API.
Compare to the architecture sketch from Chapter \ref{chapter:architecture}.
\ExaHyPE's Python API can be read as builder mechanism:
You configure your particular \ExaHyPE\ application, i.e.~you tell the \ExaHyPE\
engine which application you want to run (which PDE terms, which solver
variants, which hardware properties).
The Python API then yields both a \Peano\ Python project which you can run plus
a set of template classes which you implement with your particular application.


The present document discusses how to create an \ExaHyPE\ application from
scratch.
Most application experts might not want to do this and instead use a read-to-use
\ExaHyPE\ application.
The most prominent (and maybe powerful) code using the ExaHyPE engine is maybe
ExaSeis; used to simulate seismic waves.
The details of these domain-specific codes are not covered by the present
document.



\section*{Preparing \Peano\ to run \ExaHyPE}

It is relatively straightforward to use \ExaHyPE\ within \Peano:

\begin{itemize}
  \item Configure your code with the flag \texttt{--with-exahype}.
  \item Recompile your code. This should give you a couple of
  \texttt{ExaHyPE2Core} libraries in the respective subdirectories.
  \item Ensure that \texttt{python/exahype} is in your Python search path.
\end{itemize}


\section*{Difference of \ExaHyPE\ vs.~ExaHyPE (first generation)}

The original ExaHyPE had been built on top of Peano (third generation) and tried
to hide as much of Peano away as possible.
In \ExaHyPE, I go the opposite way: \ExaHyPE\ is a full-blown Peano add-in and I
try not to hide anything away.
Where we designed our own data management on top of Peano in ExaHyPE, all the
data management (as well as parallelisation, e.g.) is native \Peano.


With the migration from a sole-C++ philosophy to C++ supplemented by a Python
API in \Peano, I also dumped ExaHyPE's former configuration/specification file
pradigma.
An \ExaHyPE\ application now is championed by a sole Python script.
This Python script yields a native \Peano\ application (builder mechanism) which
then assembles the application.



\section{Minimalistic Finite Volumes for the Euler equations}


We provide a complete Finite Volume implementation of a plain Euler solver
realised with \ExaHyPE. 
This solver relies on a Rusanov flux and can, with only a few lines, be
changed into an ADER-DG scheme later.
Indeed, it can be used by an ADER-DG scheme as a limiter later on.
All example data can be found within the directory
\texttt{python/examples/exahype2/finitevolumes}.


\subsection{Preparation}

Our centrel Euler script first includes a couple of tools that we need to work
with \ExaHyPE:

\begin{code}
import peano4
import peano4.datamodel
import peano4.solversteps
import peano4.output
import peano4.visualisation
import peano4.toolbox.blockstructured

import exahype2
\end{code} 


\noindent
Different to a \Peano\ application, we now do create an \ExaHyPE\ project
instance
\begin{code}
project = exahype2.Project( ["examples", "exahype2", "finitevolumes"], "finitevolumes", "." )
\end{code}
\noindent
which is assigned a subnamespace, a project name and an output path.


Next, we add the Finite Volumes solver to the project. 
This step also specifies the number of unknowns and the patch sizes that we want
to use:
\begin{code}
patch_size = 25
unknowns   = 5
project.add_finite_volumes_solver("Euler", patch_size, unknowns, 0.0001)
\end{code}
\noindent
The solver is called \texttt{Euler}.


Once this minimalist \ExaHyPE\ project is done, we ask it to generate a \Peano\
project for us, let this project parse our configure script's outcome (so that
we use the same compiler settings and other options), and we also tell \Peano\
where to find our \ExaHyPE\ libraries.
Please note that \Peano\ builds these libraries in different variants
(production runs, tracing or debugging flavours, \ldots).
Select the right one:

\begin{code}
peano4_project = project.generate_Peano4_project()
peano4_project.output.makefile.parse_configure_script_outcome( "../../../.." )
peano4_project.output.makefile.add_library( "ExaHyPE2Core2d_debug", "../../../../src/exahype2" )
peano4_project.generate(peano4.output.Overwrite.Default)
peano4_project.build()
\end{code}


\noindent
We can directly run this code (though it does nothing so far and might even
crash as we haven't set initial conditions properly) via
\begin{code}
success = peano4_project.run( [] )
\end{code}
within the Python workbench. 
Alternatively, you can invoke the code directly from the command line. 



\subsection{Implementing the Euler solver}

The run of \ExaHyPE\ so far has given us a lot of glue code (which we will
never touch) and three files in the main directory:
\texttt{AbstractEuler.h}, \texttt{Euler.h} and \texttt{Euler.cpp}.
It is the last one that we have to alter to inject our domain knowledge,
i.e.~the PDE\footnote{If you regenerate your \ExaHyPE\ code later on, it will
overwrite the Abstract\ldots solver classes, but it will never modify your
actual solver instances. So if signatures change, you will have to alter these
guys manually.}.


There are three routines that require our attention.
The first one is \texttt{adjustSolution}.
We can use this routine to overwrite the solution at any time and, hence, to
inject boundary conditions or stimuli into the domain.
It is also this routine that allows us to realise initial conditions:
\begin{code}
void examples::exahype2::finitevolumes::Euler::adjustSolution(
  double Q[5],
  const tarch::la::Vector<Dimensions,double>&  x,
  const tarch::la::Vector<Dimensions,double>&  h,
  const tarch::la::Vector<Dimensions,double>&  t
) {
  if (tarch::la::equals(t,0.0) ) {
    // initial conditions
    bool isInTheCentre = ( tarch::la::norm2( x-tarch::la::Vector<Dimensions,double>(0.5) ) < 0.05 );
    Q[0] = 1.0;  // rho
    Q[1] = 0;    // velocities
    Q[2] = 0;
    Q[3] = 0;
    Q[4] = isInTheCentre ? 1.0 : 0.0; // inner energy
  }
}
\end{code}


\noindent
As second and third step, we have to write our actual flux and eigenvalue
functions as we need them for Rusanov:
\begin{code}
void examples::exahype2::finitevolumes::Euler::eigenvalues(
  double                                       Q[5],
  const tarch::la::Vector<Dimensions,double>&  faceCentre,
  const tarch::la::Vector<Dimensions,double>&  volumeH,
  const tarch::la::Vector<Dimensions,double>&  t,
  int                                          normal,
  double                                       lambda[5]
) {
  constexpr double gamma = 1.4;
  const double irho = 1./Q[0];
  #if Dimensions==3
  const double p = (gamma-1) * (Q[4] - 0.5*irho*Q[1]*Q[1]+Q[2]*Q[2]+Q[3]*Q[3]);
  #else
  const double p = (gamma-1) * (Q[4] - 0.5*irho*Q[1]*Q[1]+Q[2]*Q[2]);
  #endif

  const double u_n = Q[normal + 1] * irho;
  const double c   = std::sqrt(gamma * p * irho);

  lambda[0]  = u_n;
  lambda[1]  = u_n;
  lambda[2]  = u_n;
  lambda[3]  = u_n + c;
  lambda[4]  = u_n - c;
}
\end{code}

\begin{code}
void examples::exahype2::finitevolumes::Euler::flux(
  double                                       Q[5],
  const tarch::la::Vector<Dimensions,double>&  faceCentre,
  const tarch::la::Vector<Dimensions,double>&  volumeH,
  const tarch::la::Vector<Dimensions,double>&  t,
  int                                          normal,
  double                                       F[5]
) {
  constexpr double gamma = 1.4;
  const double irho = 1./Q[0];
  #if Dimensions==3
  const double p = (gamma-1) * (Q[4] - 0.5*irho*Q[1]*Q[1]+Q[2]*Q[2]+Q[3]*Q[3]);
  #else
  const double p = (gamma-1) * (Q[4] - 0.5*irho*Q[1]*Q[1]+Q[2]*Q[2]);
  #endif

  switch (normal) {
    case 0:
        {
          F[0] = Q[1];
          F[1] = irho*Q[1]*Q[1] + p;
          F[2] = irho*Q[2]*Q[1];
          F[3] = (Dimensions==3) ? irho*Q[3]*Q[1] : 0.0;
          F[4] = irho*(Q[4]+p)*Q[1];
        }
        break;
    case 1:
        {
          F[0] = Q[2];
          F[1] = irho*Q[1]*Q[2];
          F[2] = irho*Q[2]*Q[2] + p;
          F[3] = (Dimensions==3) ? irho*Q[3]*Q[2] : 0.0;
          F[4] = irho*(Q[4]+p)*Q[2];
        }
        break;
    case 2:
        {
          F[0] = Q[3];
          F[1] = irho*Q[1]*Q[3];
          F[2] = irho*Q[2]*Q[3];
          F[3] = (Dimensions==3) ? irho*Q[3]*Q[3] + p : 0.0;
          F[4] = irho*(Q[4]+p)*Q[3];
        }
        break;
  }
}
\end{code}


\noindent
There are quite a lot of assertions in the code in the repository that you might
want to skip (and I didn't paste them in here).
I found them useful when I wrote \ExaHyPE\ in the first place.
With these implementations in place, you can finally type in \texttt{make} in
the project directory and rerun the code.
Alternatively, just re-execute the whole Python script.
You'll get your first wave equation solver

Some simple boundary conditions close the system:

\begin{code}
void examples::exahype2::finitevolumes::Euler::boundaryConditions(
  double                                       Qinside[5],
  double                                       Qoutside[5],
  const tarch::la::Vector<Dimensions,double>&  faceCentre,
  const tarch::la::Vector<Dimensions,double>&  volumeH,
  const tarch::la::Vector<Dimensions,double>&  t,
  int                                          normal
) {
  Qoutside[0] = Qinside[0];
  Qoutside[1] = Qinside[1];
  Qoutside[2] = Qinside[2];
  Qoutside[3] = Qinside[3];
  Qoutside[4] = Qinside[4];
}
\end{code}



\subsection{Configuring the overall run}

\ExaHyPE's Python interface gives you the opportunity to specify exactly which
domain you want to use, how often to plot, and when to shut down the simulation.
For a first trial, we set the parameters as follows:
\begin{code}
project.set_global_simulation_parameters(
  2,         # Dimensions
  [0.0,0.0], # Offset of computational domain
  [1.0,1.0], # Size of computational domain
  0.2,       # Terminal time, i.e. we simulate from 0 to 0.2
  0.0,       # First snapshot of solution is done after grid construction, i.e. at time 0
  0.001      # We then plot every 0.001 time units
)
\end{code}
\noindent
This is all. We now can run the code.



\ExaHyPE\ codes by default yield snapshots in \Peano's block format. 
If you have configured \Peano\ with VTK support, you can directly convert it
into VTK and visualise through Paraview or VisIt, e.g.:
\begin{code}
if success:
  convert = peano4.visualisation.Convert( "solutionEuler" )
  convert.set_visualisation_tools_path( "../../../../src/visualisation" )
  convert.extract_fine_grid()
  convert.convert_to_vtk()
\end{code}
