\chapter{\ExaHyPE}
\label{section:python-api-examples:finite-volumes}


\begin{figure}[htb]
 \begin{center}
  \includegraphics[width=0.2\textwidth]{60_exahype/EU.png}
  \includegraphics[width=0.5\textwidth]{60_exahype/ExaHyPE_Logo.jpg}
 \end{center}
 \caption{
   The original ExaHyPE project delivering the first generation of the ExaHyPE
   software has received funding from the European Union’s Horizon 2020 research
   and innovation programme under grant agreement No 671698 (ExaHyPE).
 }
\end{figure}

\noindent
\ExaHyPE\ is the follow-up development of the ExaHyPE project which has been
funded by the EU from 2015--2019.
The present version is the second generation of the code (\ExaHyPE) and has
seen substantial rewrites of core routines.
However, many paradigms and even code blocks remain the same.
Migrating from the original ExaHyPE to \ExaHyPE\ thus should be straightforward.


\ExaHyPE\ is both a set of C/C++ and Fortran core routines complementing the
\Peano\ core and a high-level augmentation of \Peano's Python API.
Compare to the architecture sketch from Chapter \ref{chapter:architecture}.
\ExaHyPE's Python API can be read as builder mechanism:
You configure your particular \ExaHyPE\ application, i.e.~you tell the \ExaHyPE\
engine which application you want to run (which PDE terms, which solver
variants, which hardware properties).
The Python API then yields both a \Peano\ Python project which you can run plus
a set of template classes which you implement with your particular application.


The present document discusses how to create an \ExaHyPE\ application from
scratch.
Most application experts might not want to do this and instead use a read-to-use
\ExaHyPE\ application.
The most prominent (and maybe powerful) code using the ExaHyPE engine is maybe
ExaSeis; used to simulate seismic waves.
The details of these domain-specific codes are not covered by the present
document.



\section*{Preparing \Peano\ to run \ExaHyPE}

It is relatively straightforward to use \ExaHyPE\ within \Peano:

\begin{itemize}
  \item Configure your code with the flag \texttt{--with-exahype}.
  \item Recompile your code. This should give you a couple of
  \texttt{ExaHyPE2Core} libraries in the respective subdirectories.
  \item Ensure that \texttt{python/exahype} is in your Python search path.
\end{itemize}


\section*{Difference of \ExaHyPE\ vs.~ExaHyPE (first generation)}

The original ExaHyPE had been built on top of Peano (third generation) and tried
to hide as much of Peano away as possible.
In \ExaHyPE, I go the opposite way: \ExaHyPE\ is a full-blown Peano add-in and I
try not to hide anything away.
Where we designed our own data management on top of Peano in ExaHyPE, all the
data management (as well as parallelisation, e.g.) is native \Peano.


With the migration from a sole-C++ philosophy to C++ supplemented by a Python
API in \Peano, I also dumped ExaHyPE's former configuration/specification file
pradigma.
An \ExaHyPE\ application now is championed by a sole Python script.
This Python script yields a native \Peano\ application (builder mechanism) which
then assembles the application.



\section{Minimalistic Finite Volumes for the Euler equations}


We provide a complete Finite Volume implementation of a plain Euler solver
realised with \ExaHyPE. 
This solver relies on a Rusanov flux and can, with only a few lines, be
changed into an ADER-DG scheme later.
Indeed, it can be used by an ADER-DG scheme as a limiter later on.
All example data can be found within the directory
\texttt{python/examples/exahype2/finitevolumes}.


\subsection{Preparation}

Our centrel Euler script first includes a couple of tools that we need to work
with \ExaHyPE:

\begin{code}
import peano4
import peano4.datamodel
import peano4.solversteps
import peano4.output
import peano4.visualisation
import peano4.toolbox.blockstructured

import exahype2
\end{code} 


\noindent
Different to a \Peano\ application, we now do create an \ExaHyPE\ project
instance
\begin{code}
project = exahype2.Project( ["examples", "exahype2", "finitevolumes"], "finitevolumes", "." )
\end{code}
\noindent
which is assigned a subnamespace, a project name and an output path.


Next, we add the Finite Volumes solver to the project. 
This step also specifies the number of unknowns and the patch sizes that we want
to use:
\begin{code}
patch_size = 25
unknowns   = 5
project.add_finite_volumes_solver("Euler", patch_size, unknowns, 0.0001)
\end{code}
\noindent
The solver is called \texttt{Euler}.


Once this minimalist \ExaHyPE\ project is done, we ask it to generate a \Peano\
project for us, let this project parse our configure script's outcome (so that
we use the same compiler settings and other options), and we also tell \Peano\
where to find our \ExaHyPE\ libraries.
Please note that \Peano\ builds these libraries in different variants
(production runs, tracing or debugging flavours, \ldots).
Select the right one:

\begin{code}
peano4_project = project.generate_Peano4_project()
peano4_project.output.makefile.parse_configure_script_outcome( "../../../.." )
peano4_project.output.makefile.add_library( "ExaHyPE2Core2d_debug", "../../../../src/exahype2" )
peano4_project.generate(peano4.output.Overwrite.Default)
peano4_project.build()
\end{code}


\noindent
We can directly run this code (though it does nothing so far and might even
crash as we haven't set initial conditions properly) via
\begin{code}
success = peano4_project.run( [] )
\end{code}
within the Python workbench. 
Alternatively, you can invoke the code directly from the command line. 



\subsection{Implementing the Euler solver}

The run of \ExaHyPE\ so far has given us a lot of glue code (which we will
never touch) and three files in the main directory:
\texttt{AbstractEuler.h}, \texttt{Euler.h} and \texttt{Euler.cpp}.
It is the last one that we have to alter to inject our domain knowledge,
i.e.~the PDE\footnote{If you regenerate your \ExaHyPE\ code later on, it will
overwrite the Abstract\ldots solver classes, but it will never modify your
actual solver instances. So if signatures change, you will have to alter these
guys manually.}.


There are three routines that require our attention.
The first one is \texttt{adjustSolution}.
We can use this routine to overwrite the solution at any time and, hence, to
inject boundary conditions or stimuli into the domain.
It is also this routine that allows us to realise initial conditions:
\begin{code}
void examples::exahype2::finitevolumes::Euler::adjustSolution(
  double Q[5],
  const tarch::la::Vector<Dimensions,double>&  x,
  const tarch::la::Vector<Dimensions,double>&  h,
  const tarch::la::Vector<Dimensions,double>&  t
) {
  if (tarch::la::equals(t,0.0) ) {
    // initial conditions
    bool isInTheCentre = ( tarch::la::norm2( x-tarch::la::Vector<Dimensions,double>(0.5) ) < 0.05 );
    Q[0] = 1.0;  // rho
    Q[1] = 0;    // velocities
    Q[2] = 0;
    Q[3] = 0;
    Q[4] = isInTheCentre ? 1.0 : 0.0; // inner energy
  }
}
\end{code}


\noindent
As second and third step, we have to write our actual flux and eigenvalue
functions as we need them for Rusanov:

\attachfile[icon=Paperclip,description=Download code snippet,author=Peano 4]
{60_exahype/Euler-eigenvalues.cpp}

\begin{code}
void examples::exahype2::finitevolumes::Euler::eigenvalues(
  double                                       Q[5],
  const tarch::la::Vector<Dimensions,double>&  faceCentre,
  const tarch::la::Vector<Dimensions,double>&  volumeH,
  const tarch::la::Vector<Dimensions,double>&  t,
  int                                          normal,
  double                                       lambda[5]
) {
  [...]
}
\end{code}



\attachfile[icon=Paperclip,description=Download code snippet,author=Peano 4]
{60_exahype/Euler-flux.cpp}


\begin{code}
void examples::exahype2::finitevolumes::Euler::flux(
  double                                       Q[5],
  const tarch::la::Vector<Dimensions,double>&  faceCentre,
  const tarch::la::Vector<Dimensions,double>&  volumeH,
  const tarch::la::Vector<Dimensions,double>&  t,
  int                                          normal,
  double                                       F[5]
) {
  [...]
}
\end{code}


\noindent
There are quite a lot of assertions in the code in the repository that you might
want to skip (and I didn't paste them in here).
I found them useful when I wrote \ExaHyPE\ in the first place.
With these implementations in place, you can finally type in \texttt{make} in
the project directory and rerun the code.
Alternatively, just re-execute the whole Python script.
You'll get your first wave equation solver

Some simple boundary conditions close the system:

\begin{code}
void examples::exahype2::finitevolumes::Euler::boundaryConditions(
  double                                       Qinside[5],
  double                                       Qoutside[5],
  const tarch::la::Vector<Dimensions,double>&  faceCentre,
  const tarch::la::Vector<Dimensions,double>&  volumeH,
  const tarch::la::Vector<Dimensions,double>&  t,
  int                                          normal
) {
  Qoutside[0] = Qinside[0];
  Qoutside[1] = Qinside[1];
  Qoutside[2] = Qinside[2];
  Qoutside[3] = Qinside[3];
  Qoutside[4] = Qinside[4];
}
\end{code}



\subsection{Configuring the overall run}

\ExaHyPE's Python interface gives you the opportunity to specify exactly which
domain you want to use, how often to plot, and when to shut down the simulation.
For a first trial, we set the parameters as follows:
\begin{code}
project.set_global_simulation_parameters(
  2,         # Dimensions
  [0.0,0.0], # Offset of computational domain
  [1.0,1.0], # Size of computational domain
  0.2,       # Terminal time, i.e. we simulate from 0 to 0.2
  0.0,       # First snapshot of solution is done after grid construction, i.e. at time 0
  0.001      # We then plot every 0.001 time units
)
\end{code}
\noindent
This is all. We now can run the code.



\ExaHyPE\ codes by default yield snapshots in \Peano's block format. 
If you have configured \Peano\ with VTK support, you can directly convert it
into VTK and visualise through Paraview or VisIt, e.g.:
\begin{code}
if success:
  convert = peano4.visualisation.Convert( "solutionEuler" )
  convert.set_visualisation_tools_path( "../../../../src/visualisation" )
  convert.extract_fine_grid()
  convert.convert_to_vtk()
\end{code}


\section{Running on a parallel computer}

\marginpar{Currently under construction}

To run \ExaHyPE\ in parallel, you have to build \Peano\ with support for
multithreading and/or MPI.
Once this is done, the engine more or less runs in parallel out of the box, as I
offer a couple of default load balancing and decomposition strategies. 
So here's a summary of what has to be done:



\begin{enumerate}
  \item Rerun the configure script with MPI and/or shared memory enabled. If you
  have done so already, you can skip this step.
  \item Identify one solver of your code that serves as load balancer. If you
  use only one solver, then this is trivial. I continue to develop the Euler
  example from the previous sections, so my solver of choice is \texttt{Euler}.
  In the examples I ship with the code, I however relabel it into
  \texttt{ParallelEuler}, so users doing the first steps are not flooded with
  parallelisation details.
  \item Add an instance of \texttt{toolbox::loadbalancing::RecursiveGuided} to
  this solver. You can later on use more sophisticated balancing strategies, but
  this seems to be a good starting point. Here's a simpel example:
  \begin{code}
class examples::exahype2::finitevolumes::Euler: public AbstractEuler {
  private:
    toolbox::loadbalancing::RecursiveGuided  _loadBalancer;
  public:
    [...]
};
  \end{code}
    You will have to add the corresponding include, too.
  \item All the premanufactored (toolbox) load balancers are packaged into a
  library of their own. You have to add this library to your \Peano\ project in
  the Python script:
  \begin{code}
peano4_project = project.generate_Peano4_project()
peano4_project.output.makefile.parse_configure_script_outcome( "../../../.." )
peano4_project.output.makefile.add_library( "ExaHyPE2Core2d_debug", "../../../../src/exahype2" )
peano4_project.output.makefile.add_library( 
  "ToolboxLoadBalancing2d_debug", "../../../../src/toolbox/loadbalancing" )
[...]
  \end{code}
  \item We hook into the solver's \texttt{finishTimeStep} call to brief the load
  balancing. For this, we override the routine in our solver:
  \begin{code}
class Euler: [...]
    void finishTimeStep() override;
  \end{code}
  This routine always has been there but is implemented as a dummy in the
  abstract solver base class.
  \item When we implement \texttt{finishTimeStep}, we have to ensure we still
  invoke the base class' dummy implementation (we don't want to alter semantics)
  and then we actually tell the load balancing to become active:
  \begin{code}
void examples::exahype2::finitevolumes::Euler::finishTimeStep() {
  AbstractEuler::finishTimeStep();
  _loadBalancer.finishTimeStep(); 
}
  \end{code}
  \item If you rely on \Peano's VTK conversion utilities, i.e.~if you have
  configured your code with VTK, then the conversion tools can handle parallel
  data dumps. My implementation likely is not the best one possible, as I do
  dump data files in parallel, but the conversion tool then merges all of the
  data into one big VTK/VTU file. For most of the applications, the
  premanufactured VTK dump is a good start though.
\end{enumerate}


\section{Introducing a new solver (numerical scheme)}

This section discusses how to introduce a totally new numerical solver. 
It does not discuss how to introduce a new PDE, as new PDEs are built on top of
\ExaHyPE.
This section gives you an idea how to extend \ExaHyPE\ instead.

\begin{remark}
  \ExaHyPE\ is a very high level Python API which generates a \Peano\
   Python project which in turn creates the ``real'' \Peano\ C/C++ code. If you
   introduce a new numerical scheme/solver to \ExaHyPE, you thus might want to
   familiarise yourself with \Peano's Python API and how to extend it. This
   recommendation affects all the gluecode/framework aspects of the software.
   All the core numerics of \ExaHyPE\ are held as C++ code in the
   \texttt{src/exahype2} directly and compiled into a separate library. If you
   introduce new numerical schemes, you might have to extend this library, too.
\end{remark}


\paragraph{A new Finite Volume solver}



\section*{Links and further reading}

\begin{itemize}
  \item The ``official'' ExaHyPE release paper is
  \begin{verbatim}
@article{Reinarz:2019:ExaHyPE,   
  author    = {Anne Reinarz and Dominic E. Charrier and Michael Bader 
    and Luke Bovard and Michael Dumbser and Kenneth Duru and 
    Francesco Fambri and Alice-Agnes Gabriel and Jean-Mathieu Gallard 
    and Sven Köppel and Lukas Krenz and Leonhard Rannabauer and 
    Luciano Rezzolla and Philipp Samfass and Maurizio Tavelli and 
    Tobias Weinzierl}, 
  title     = {ExaHyPE: An Engine for Parallel Dynamically Adaptive 
    Simulations of Wave Problems},   
  journal   = {},
  volume    = {},   
  number    = {},
  pages     = {},
  year      = {2019},   
  note      = {(arXiv:1905.07987)} 
}   
  \end{verbatim}
  If you use the software, it would be great if you could cite this one.
\end{itemize}

