\chapter{Troubleshooting}

\section{PDT}

\begin{itemize}
  \item {\bf The PDT does not pass as the jar file is built with the wrong Java
  version}. Download the whole Peano project (from sourceforge via subversion),
  change into the directory \texttt{pdt/src}, and run
  \begin{code}
  make clean
  make createParser
  make compile
  make dist
  \end{code}
  Use the \texttt{pdt.jar} from the \texttt{pdt} directory now. 
\end{itemize}


%update-alterantives --config java



\section{Programming}

\begin{itemize}
  \item {\bf How can I find out the location of a cell}. See the documentation
  of the \texttt{VertexEnumerator}. The object has routines to query cell
  position, size and level in the spacetree.
  \item {\bf The adaptivity pattern lacks behing my adaptivity instructions}.
  For most refinement and erase calls, Peano needs at least one iteration to
  reliase them. It tries to do it faster, but usually needs these two
  iterations. Whenever Peano encounters regular subtrees, it tries to store 
  them separately in some arrays and process it way faster than with a classic
  tree. When a refinement command affects such a regular subregion, we first 
  have to find this region (at least one sweep), then break it up, in the
  follow-up iteration remove all veto markers that stopped the regular grid to
  be refined and then we can realise the refinement. If you have an extremely
  rapidely changing grid and you can't wait for Peano to keep pace, you should
  compile with \texttt{-DnoPersistentRegularSubtrees}. This will make the grid
  react quicker to your refinement requests but might slow down the code
  significantly.
  \item {\bf I need the state object in my mapping}. Create a copy of the state
  object in \texttt{beginIteration} and to merge this copy back in \texttt{endIteration}. 
  Peano updates the State itself and the state position in memory is not fixed.
  Do never ever hold a pointer to the state object handed into
  \texttt{beginIteration} or \texttt{endIteration}.
\end{itemize}


\section{Application tailoring}

\begin{itemize}
  \item {\bf The code requires too much memory}.
  You can try to compile your code with
  \linebreak \texttt{-DnoPersistentRegularSubtrees}.
  However, this may lead to a severe performance \linebreak
  degradation---notably if you run your code with shared memory parallelisation.
\end{itemize}

\section{MPI troubleshooting}

\begin{itemize}
  \item {\bf Does Peano support MPI-2?}. Yes, you can switch to MPI-2 if you add
  \texttt{-DMPI2}. I have experienced some issues with MPI-2 implementations and
  user-defined datatypes and thus decided to make MPI 1.3 the default. If you
  switch to MPI-2 and experience problems, you  mgiht want to have a look into
  any \texttt{records} directory and search for \texttt{initDatatype} to
  understand where issues arise.
  \item {\bf I've altered my data types and MPI starts to crash}. There are
  multiple reasons why user-defined data types start to fail. Here are some
  ideas to follow-up:
    \begin{enumerate}
      \item Compile with \texttt{-DAsserts}. We augment all parts of Peano with
      lots and lots of assertions, so they might help you to hunt down bugs.
      \item We have seen some compilers fail if you label some attributes of
      (vertex) data types with \texttt{expose}. Expose does alter the
      visibility, and we came to believe that these visibility modifications
      make some compilers reorder class attributes which in turns means that the
      MPI data types hold invalid byte offsets.
    \end{enumerate}
  \item To be continued \ldots
%  \item {\bf The adaptivity pattern lacks behing my adaptivity instructions}.
\end{itemize}


