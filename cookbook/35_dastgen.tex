\section{Data modelling and access}


\chapterDescription
  {
  } { 
    We quickly summarise how and why data is modelled in Peano and we show the 
    different patterns we see to access this data. So no application is required 
    but it certainly helps to have an example at hands.
  }
  
\noindent
Peano models its data structures via a tool called DaStGen (Data Structure
Generator).
DaStGen is a C++ source-to-source compiler which accepts augmented C++ data
structures and pipes out plain C++ structures.
The generated data structures offer some useful features: they can be stored in
a very compact way (with low padding/overhead), they support mixed precision,
they offer user-defined MPI data types, and so forth.
Originally, DaStGen has been designed to be completely independent of Peano. 
It still is but we find that basically only Peano uses it.
So we make it part of the PDT jars and to not require users to install it
separately.
If you want to create your own variant of the tool, you however can obtain it
independently from Peano at \url{https://sourceforge.net/projects/dastgen}.


DaStGen's vision and integration into Peano are very simple:
\begin{itemize}
  \item Model your data structures, i.e.~only your class attributes, as
  C++ish class in the special DaStGen syntax. These are the \texttt{.def} files.
  \item Include the files into the specification file.
  \item The PDT triggers the DaStGen tool and makes it generate plain C++
  classes which are held in the \texttt{records} subdirectory.
  \item A Peano application works against these records.
\end{itemize} 


\subsection{Including DaStGen files}

Peano's PDT expects users to model at least three data types with DaStGen: the
vertex data, the cell data and the state data.
These data types have to specified in the files \texttt{Vertex.def},
\texttt{Cell.def} and \texttt{State.def}.
If you don't model data to sit inside these grid entities, you can leave the
files empty, i.e. without any attributes.
However, the PDT itself augments them with data that Peano needs for the grid
management.
So the generated files never are empty.



If you need additional files modelled with DaStGen, create the files and add a
statement
\begin{code}
heap-dastgen-file: MyFileA.def
heap-dastgen-file: MyFileB.def
\end{code}
\noindent
to the specification file. This mainly is needed if you work with heaps and
therefore the keyword refers to the heap. 
If such a statement is inserted into the specification file, the PDT runs
DaStGen on these files, too.



\subsection{Working with DaStGen records}

There are three ways to work with records created by DaStGen:
\begin{enumerate}
  \item DaStGen generates plain C++ classes. They have getters and setters.
  These routines internally can convert data (and thus support
  tailored/specialised data formats where a Boolean for example consumes only
  one bit rather than a whole byte). This is the classic/academic
  object-oriented way to access data.
  
  Peano's state, vertex and cell data coming along with the framework are
  wrappers around the DaStGen records (they realise the flyweight pattern of
  the GoF): if you model an integer \texttt{abc} within your def-file, this
  attribute will be embedded into a records class generated by DaStGen. Peano's
  \texttt{Vertex} class now holds an attribute \texttt{\_vertexData} which in
  turn holds the attribute \texttt{abc}. If you want to expose the
  attribute---you might want to access it directly from a mapping, e.g.---you
  have to add a \texttt{getAbc} routine to your vertex and delegate the call to
  the aggregate:
  \begin{code}
int myproject::Vertex::getAbc() {
  return _vertexData.getAbc();
}
  \end{code}
  \item DaStGen generates well-engineered C++ classes where data is made private
  and the toolkit thus can track accesses and check validity if you set data. If
  you find it cumbersome to write getters and setters for your vertex/cell/state
  classes aggregating the DaStGen object, then you can mark attribute within
  DaStGen's \texttt{def}-file as \texttt{expose}. In this case, they are made
  public. You loose however the ability to compactify and rearrange data, and
  you loose all the validity checks.
  \item The classes (records) generated by DaStGen are made attributes of
  Peano's vertex, cell and state. If you want to access data within mappings,
  e.g., you now have to add getters and setters to the vertex and cell class.
  If you want to circumnavigate this, you can add read and write statements to
  your specification file. This tells then the PDT to create a set of utility
  routines in a file called \texttt{VertexOperations}. The routines in there are
  static and made friends of the DaStGen records. They allow you to read and
  write data to them and also provide features to work with sets of the entities
  in the grid. The routines thus break the idea of object-oriented programming
  to some degree. 
\end{enumerate}

\noindent
The following access routines are supported by the PDT:

\begin{center}
\begin{tabular}{p{4.6cm}p{7.2cm}p{1.8cm}}
 \texttt{read scalar(double): U}
   & 
   The code assumes that your vertex has a double attribute \texttt{U}. As you
   add this read statement to your specification file, \texttt{VertexOperations}
   will contain a routine \texttt{readU} that allows you to read out the
   \texttt{U}-value (despite the fact that it is actually aggregated by the
   vertex).
   There will also be a read routine that accepts an enumerator of a cell and a
   pointer to vertices and then gives you back a vector of $2^d$
   \texttt{U}-values, i.e.~of all the values of the four (2d) vertices of one
   cell.
   &
   There is a \texttt{write} counterpart.
   The routine can also be specified to work on \texttt{int} and
   \texttt{complex}. \\
 \texttt{read vector(double): U}
   & 
   The code assumes that your vertex has an attribute \texttt{U} which is a
   $d$-dimensional vector, i.e.~an array \texttt{double U[DIMENSIONS]}.
   \texttt{VertexOperations}' access routines allow you either to modify/read
   individual entries of this vector or work with the whole vector type. The
   routines that work with all vertices of a cell now works with double vectors
   of length $2^d \cdot d$.
   \\
 \texttt{read vector2PowD(double): U}
   & 
   Same as \texttt{read vector(double)} but the statement assumes that the
   vertex's attribute has \texttt{TWO\_POWER\_D}, i.e.~$2^d$ entries.
   \\
 \texttt{read intergrid-operator(double): U}
   & 
   Same as \texttt{read vector(double)} but the statement assumes that the
   vertex's attribute has $5^d$ entries.
   \\
 \texttt{read stencil(double): U}
   & 
   Same as \texttt{read vector(double)} but the statement assumes that the
   vertex's attribute has $3^d$ entries.
\end{tabular}
\end{center}

\noindent
The PDE offers support for scalar attributes and attributes of various
cardinalities.
Obviously, there are always cardinalities that the toolkit does not support.
In this case, you have to write read and write routines yourself or you stick to
the other two access options discussed above.
In any case, the generated \texttt{VertexOperations} routines might be a good
template.



\subsection{DaStGen specification files}

The syntax of DaStGen files follows C++.
\begin{code}
class myproject::records::Vertex {  
  /**
   * Some fancy comment
   */
  persistent double   epsilon;
};
\end{code}

\noindent
Each \texttt{def}-file has to contain exactly one ``DaStGen'' class.
Yet, DaStGen files can include other files through 
\begin{code}
  \include Base.def
\end{code}


\noindent
Including other \texttt{def}-files is first mapped onto inheritance.
In the example above, \texttt{Vertex} would inherit from data specified in
\texttt{Base.def} (whatever the file name in the latter file is).
However the inheritance is flattened, i.e.~the attributes are copied over.
You'll not find real C++ inheritance.

% \code
% \endcode

\paragraph{Packing}

One unique selling point of DaStGen is its ability to pack data.
In C++, a Boolean is mapped onto a primitive data type and thus requires at
least one byte.
If you have $k$ bools, you thus waste at least $7k$ bits.
If you mark attributes in the \texttt{def} file as \texttt{packed}, DaStGen
embeds all of these fields into one packed type and realises all the bit
manipulation routines. 
This is all done automatically. 
Yet, the tool needs a 
\begin{code}
Packed-Type: short int;
\end{code}

\noindent
statement at the file start which tells us onto which built-in C datatype all
these bits are to be mapped onto.


If you work with integer data types, you can add range annotations:
\begin{code}
packed int from 0 to 7;
\end{code}

\noindent
In this case, the integer internally also is mapped onto a bit field and it
needs only four bits rather than a whole C++ integer.


\paragraph{Persistent data}
In many applications, there are attributes of vertices and cells that are
persistent and there are attributes that are only required throughout the
traversal.
Yet, there's not need to store them in-between two grid sweeps/iterations.
An example often following this pattern are residuals that are accumulated.


DaStGen allows us to annotate attributes with \texttt{persistent} and
\texttt{discard} to mirror this lifecycle.
Annotating as many attributes as possible with \texttt{discard} reduces the
code's memory footprint.
 


\paragraph{MPI data}

If you exchange a vertex or cell via MPI, it sometimes is convenient not to
exchange all data but only those attributes your code actually needs.
A careful choice reduces the bandwidth demands.
In DaStGen, simply add a \texttt{parallelise} keyword (AE is supported, too) to
an attribute.
Per DaStGen type, the tool generates two user-defined MPI datatypes: 
one can be used to send around whole C++ objects.
The other one can be used to exchange only those object attributes that are
marked with \texttt{parallelise}.
Peano's boundary data exchange relies on the latter datatype.


\paragraph{Arrays}

DaStGen supports solely arrays of fixed size.
Instead of adding a fixed number of the size, you can however use symbolic
constants as long as you inform DaStGen that something is a constant defined at
compile time:
\begin{code}
Constant: DIMENSIONS;

class boxmg::records::Vertex {  
  persistent double   epsilon[DIMENSIONS];
};
\end{code}

\noindent
The PDT makes all DaStGen \texttt{def}-files know all constants from
\texttt{peano/utils/Globals.h}.
So you can use all constants from there.
Please note that arrays over bools are mapped onto a bit field and thus can
be packed if they are marked with \texttt{packed}.
If you add \texttt{from}/\texttt{to} to an integer array, DaStGen can pack data,
too.



\paragraph{Further features}

There is a \texttt{friend} statement and you can define \texttt{enums} with
DaStGen. 
The enum syntax mirrors the pre-C++11 syntax.
As enums have only a limited number of variants, enumerations can also be packed
efficiently into bit fields.
DaStGen automatically generates \texttt{toString()} routines for enumerations.


It can happen that you can't be absolutely sure whether all data fits into the
packed type.
This happens notably if you have lots of arrays using symbolic, compile-time
lengths.
In this case, all packed routines might fit into a short integer for $2d$ but
fail to squeeze into a short int in the three-dimensional case. 
Furthermore, DaStGen unfortunately cannot know at compile time how big your
short integer is.
You can give DaStGen hints on this however:
\begin{code}
  Packed-Type: short int hint-size 16;
\end{code} 

\noindent
Now, DaStGen makes the packed destination type have only 16 bits. If the packed
data do not fit into 16 bits anymore, it splits them up into multiple 16 bit
values.
To tune all packing further, you can also give hints on the constants:
\begin{code}
 Constant: DIMENSION hint-value 3;
\end{code} 


If you mark attributes with \texttt{expose}, they are made C++ public.
DaStGen will continue to generate getters and setters, but you can then also
access them directly.
Obviously, exposing contradicts the idea of packing.


DaStGen supports \texttt{\#ifdef} and \texttt{\#ifndef}. 



\subsection*{Further reading}

\begin{itemize}
  \item H.-J. Bungartz, W. Eckhardt, T. Weinzierl and C. Zenger: {\em A Precompiler to
Reduce the Memory Footprint of Multiscale PDE Solvers in C++}.
In P.M.A. Sloot (ed.), Future Generation Computer Systems, Volume 26{\bf (1)},
pp.~175--182. Elsevier, 2010.
  \item H.-J. Bungartz, M. Mehl, T. Weinzierl and W. Eckhardt: {\em DaStGen - A Data
Structure Generator for Parallel C++ HPC Software}.
In Bubak, van Albada, Sloot and Dongarra (ed.), ICCS 2008: Advancing Science
through Computation, Part III, Volume 5103 of Lecture Notes in Computer Science,
pp.~213--222. Springer-Verlag, Heidelberg, Berlin, June 2008.
\end{itemize}
