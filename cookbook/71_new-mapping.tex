\chapter{Introducing a new pre-defined mapping}
\label{section:logging}

This chapter discusses how you make a mapping of your code available to other
projects as a pre-defined mapping.
As a result of such a refactoring, others can inject your ideas
straightforwardly into their project.
The name refactoring suggests that I highly recommend that you start from a
working mapping that you've written manually and extensively tested.

\section{Prepare classes}

Create a new subclass of \texttt{peano4.solversteps.Mapping}

\begin{code}
import peano4.solversteps.Mapping

class MyMapping(Mapping):
  def __init__(self):
    pass
\end{code}

\noindent
and ensure that Python finds the class in its path.


\section{Implement new mapping}

To implement the new mapping, you have to tell Peano what the function bodies
look like.
Before we do so, we instruct the toolkit whether this is a mapping that users
should later on edit; 
that is, your new predefined mapping serves as blueprint.
Alternatively, your mapping can be read-only and users shall not modify it.
In this case, Peano will place it in the observers' directory and always
regenerate it automatically.


The first step hence is to give your mapping a clear name (which will also be
used as class name part for the generated file) and to provide this information:


\begin{code}
  def get_mapping_name(self):
    // My default implementation that I use in the toolboxes is this following
    // line. You are however allowed to use your own, bespoke name
    // return __name__.split(".")[-1].replace(".py", "").replace(".", "_")
    return "MyName"

  def user_should_modify_template(self):
    return False
\end{code}


\noindent
The actual events are generated through the operation bodies.
All these bodies are queries through one operation. 
The query's arguments clarifies which operation body is requested

\begin{code}
  def get_body_of_operation(self,operation_name):
    # An examples where we only do something for :
    if operation_name == Mapping.OPERATION_CREATE_CELL:
      return "mycell.add(...)\n"
    return "// Nothing to implement\n"
\end{code}

\noindent
and its values are those constants in \texttt{Mapping} which start with
\texttt{OPERATION\_}.


There are further routines to control the refinement et al.
These routines are self explaining if you study the base class/interface.


More interesting is the question how to make the actual method bodies use grid
information.
For this, the canonical way is that you extend the constructor such that an
object of your mapping always ``knows'' which data they work on. 
The interfaces of all mappings are always the same, so it should be
straightforward to make your generated method bodies use the grid data once the
constructor is told what they are.


\section{Use your new mapping}

To use the mapping, you create your algorithmic steps.
Once created, you also create and instance of your mapping and you add it to the
step with \texttt{add\_mapping}.
The order in which mappings are added is important.
See \texttt{add\_mapping}'s documentation of information on this.



\section{Conventions}

By default, the Peano toolkit equips each mapping with a couple of
features/attributes:

\begin{itemize}
  \item Every mapping has a static attribute \texttt{\_log} which is an instance
  of \texttt{tarch::logging::Log}. That is, you can use Peano's logging commands
  straightaway.
\end{itemize}

